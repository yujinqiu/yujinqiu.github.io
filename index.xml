<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on Engineer&#39;s Draft </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://yujinqiu.github.io/index.xml/</link>
    
    
    
    <updated>Wed, 04 Mar 2015 10:16:31 CST</updated>
    
    <item>
      <title>Terminology</title>
      <link>http://yujinqiu.github.io/posts/Terminology/</link>
      <pubDate>Wed, 04 Mar 2015 10:16:31 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/Terminology/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Concise description&lt;/h2&gt;

&lt;p&gt;It is the client’s responsibility to perform idempotent operations or de-dupe.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BigDataDraft</title>
      <link>http://yujinqiu.github.io/posts/BigDataDraft/</link>
      <pubDate>Mon, 02 Feb 2015 20:30:22 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/BigDataDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;hbase 查看master&lt;/h2&gt;

&lt;p&gt;hbase master 信息存储在zookeeper 中, 可以在 zookeeper 中查询.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zkCli.sh -server myzoo  get  /hbase/master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;如何启动 hmaster/regionserver&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hbase-daemon.sh start master #hmaster, stop 同理
hbase-daemon.sh start regionserver #regionserver, stop 同理
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;start master 和 ./bin/start-hbase.sh 有啥区别?&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hbase-daemon.sh start master 是用来启动单个 master
./bin/start-hbase.sh 会启动整个集群, 其中会读取 hbase-0.96.2-hadoop1/conf/regionservers 用来标记 regionservers 的列表, 扩容的时候不一定需要添加进去, 因为 regionserver 的机器存储在 zookeeper.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PatternDraft</title>
      <link>http://yujinqiu.github.io/posts/PatternDraft/</link>
      <pubDate>Sun, 01 Feb 2015 13:01:41 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/PatternDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;It&amp;rsquo;s just pattern and art&lt;/h2&gt;

&lt;p&gt;工程性项目其实基本上都是固定模式的组合, 比如设计模式其实就是对编程世界的各种招式的拆解成为定式, 之所以又可以成为 art, 在于组合.  组合带来多样性和复杂性. 不同的人组合不同, favor 也不同, 然后相同 favor 的人一起组成一个 group, 然后就有派系之争.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;CRC32&lt;/h2&gt;

&lt;p&gt;经常我们期望将一个字符串转换为一个数值, 用来进行分流.  最开始自己实现的时候利用了简单的思想 将字符的 ascii 进行 sum, 上周在听 codis 分享的时候, 发现codis 利用了 CRC32算法.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FPMDraft</title>
      <link>http://yujinqiu.github.io/posts/FPMDraft/</link>
      <pubDate>Wed, 21 Jan 2015 00:08:20 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/FPMDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;FPM&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;FPM 入门&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fpm -s &amp;lt;source type&amp;gt; -t &amp;lt;target type&amp;gt; [options]
source types:  
    &amp;quot;dir&amp;quot;  可以是文件或者是目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;常见问题和解决思路&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Process failed: rpmbuild failed (exit code 1).
解决思路:  fpm 运行增加 &lt;code&gt;--verbose&lt;/code&gt; 选项, 查看日志输出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何把我的一个程序, 比如 jq 打包为 RPM 格式文件, 期望安装之后安装 到 &lt;code&gt;/bin&lt;/code&gt; 目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fpm -s dir -t rpm -n jq -v 1.4.0 --prefix=/bin/  jq


http://golang-basic.blogspot.jp/2014/10/dynamic-programming-problem-maximum.html  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;fpm 制定 package 依赖&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fpm -s dir -t rpm -n langley_online -v 1.0.0 -d &#39;thrift &amp;gt;= 0.9.1&#39; -d &#39;boost &amp;gt;= 1.41.0&#39; -d &#39;libevent &amp;gt;= 2.0.21&#39; -d &#39;fastbit &amp;gt;= 2.0.1&#39; --prefix=/home/&amp;lt;user&amp;gt;   --after-install=langley_online/install/install_hook.sh langley_online
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;如何打包 C/C++ 项目&lt;/h3&gt;

&lt;p&gt;c/c++ 项目中比较讨厌的是项目的依赖, 为了提高开发效率需要将各种依赖包打包为 RPM, 最开始一直想不明白的是, 如果我 make &amp;amp;&amp;amp; make install 之后就 pack 了, 那么如何pack呢 ?   直到今天多管闲事帮同事打包thrift之后才知道 how.&lt;/p&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;How&lt;/h4&gt;

&lt;p&gt;答案其实很简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make
make install DESTDIR=&amp;lt;dir&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般正常情况下, 会在&lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 下面生成 usr 目录, 然后利用 fpm 直接进入 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 进行打包, 指定&lt;code&gt;prefix=/&lt;/code&gt; 即可.&lt;br /&gt;
仔细思考之后, 其实 fpm 在使用 &lt;code&gt;-s dir&lt;/code&gt; 的时候的本质, 就是pack 整个包, 因此可以推断在 &lt;code&gt;./configure --prefix=&amp;lt;dir&amp;gt;&lt;/code&gt; 应该也是可以的.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;如何打包 python module&lt;/h3&gt;

&lt;p&gt;Q: 我是 python 党, 用 pip 安装 python 的各种包好方便, but 线上没有访问外网权限, 怎么破?&lt;br /&gt;
A: 为了安全线上只有部分机器可以访问外网, 因此除非你在内网搭建一个代理, 然后 pip 通过流量到 pip.  好消息是强大的 FPM 可以把python 的 pip 包打成 RPM.   python 的 thrift module 为例.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [root@svn02 ~]# fpm -s python -t rpm -a x86_64  thrift
 no value for epoch is set, defaulting to nil {:level=&amp;gt;:warn}
 no value for epoch is set, defaulting to nil {:level=&amp;gt;:warn}
 Created package {:path=&amp;gt;&amp;quot;python-thrift-0.9.2-1.x86_64.rpm&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数详解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-s INPUT_TYPE                 the package type to use as input (gem, rpm, python, etc)  
-t OUTPUT_TYPE                the type of package you want to create (deb, rpm, solaris, etc)
-a, --architecture ARCHITECTURE The architecture name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应 python module, fpm 会自动下载对应的 package, 因此只需要指定 thrift 即可.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;查看安装 pkg 详情&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rpm -q &amp;lt;pkg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@10.223.21.205:~# rpm -q thrift
thrift-0.9.2-1.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;yum 如何查看一个 rpm pkg 的详情&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum info  &amp;lt;pkg&amp;gt; 
yum list  &amp;lt;pkg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;yum 制定安装特定版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install &amp;lt;package name&amp;gt;-&amp;lt;version info&amp;gt;.&amp;lt;release info&amp;gt;.&amp;lt;architecture&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install httpd
sudo yum install httpd-2.4.6-6
sudo yum install httpd-2.4.6-6.fc20
sudo yum install httpd-2.4.6-6.fc20.x84_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;下载 rpm 包, 然后手动进行安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yumdownloader --resolve &amp;lt;package&amp;gt;
yum localinstall &amp;lt;path to rpm&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;yum 取消安装操作&lt;/h3&gt;

&lt;h4 id=&#34;toc_12&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;最近有一个glibc 安全漏洞, 安全组同学要求进行升级, 利用 yum 升级之后, 发现坑爹有问题, 需要进行回滚. 可是 glibc 依赖 package 太多, &lt;code&gt;yum downgrade pkg1.rpm pkg2.rpm ...&lt;/code&gt; 会累死人.&lt;br /&gt;
终于发现必杀技:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum history #查看历史列表

ID     | Command line             | Date and time    | Action(s)      | Altered
-------------------------------------------------------------------------------
120 | install glibc            | 2014-08-26 09:19 | Install        |    5   
yum history  undo  120 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;fpm 解决 gem 依赖问题&lt;/h3&gt;

&lt;h4 id=&#34;toc_14&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;公司有同事需要在自己的公司上的一台服务器利用 fpm 进行打包, 原来其实可以通过以下命令进行安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install ruby-devel gcc
gem install fpm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当是在想为什么不用 fpm self-bootstrap, 利用 fpm pack 自己呢.&lt;/p&gt;

&lt;p&gt;开始简单以为, 就 ok&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fpm -s gem  -t rpm  fpm 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果发现自己想简单了, fpm 底层还有各种依赖. 后面通过以下方案解决:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /tmp/gems
gem install --no-ri --no-rdoc --install-dir /tmp/gems fpm 
find /tmp/gems/cache -name &#39;*.gem&#39; | xargs -rn1 fpm -d ruby -d rubygems --prefix /usr/lib/ruby/gems/1.8 -s gem -t rpm 
然后将  生成的 rpm 放到 repo server 里边, 建立索引即可.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;--prefix&lt;/code&gt; 指的是 gem 的 &lt;code&gt;INSTALLATION DIRECTORY&lt;/code&gt; 可以通过以下方式获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@10.223.21.205:~# gem env | grep INSTALL
- INSTALLATION DIRECTORY: /usr/lib/ruby/gems/1.8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;FPM 打包升级 python2.7&lt;/h2&gt;

&lt;h3 id=&#34;toc_16&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;运维过 RHEL/CentOS 的同学基本上都知道CentOS 为了追求系统的稳定, 软件包相对来说是比较旧的. 大家抱怨比较多的是 python 的版本2.6.6 , 大家比较喜欢的是 python2.7, 因此大家迫切希望能够有python2.7 的 rpm , 一键进行升级.  其实之前升级过一次, 但是不小心把 yum 给搞坏了, 要知道 yum 其实也是 python 写的程序, 因此有一个原则需要遵守的是 python2.7 必须和 python 2.6 隔离开.&lt;/p&gt;

&lt;h3 id=&#34;toc_17&#34;&gt;安装方法&lt;/h3&gt;

&lt;p&gt;1: 下载 python2.7.9
2:  tar xf Python-2.7.9.tgz&lt;br /&gt;
3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd Python-2.7.6.tgz
# Python2.7编译安装后会安装到这个目录，方便打包
export INTERMEDIATE_INSTALL_DIR=/tmp/installdir-Python-2.7.6
# RPM包安装后Python2.7的目录
export INSTALL_DIR=/usr/local
LDFLAGS=&amp;quot;-Wl,-rpath=${INSTALL_DIR}/lib ${LDFLAGS}&amp;quot; \
./configure --prefix=${INSTALL_DIR} --enable-unicode=ucs4 \
--enable-shared --enable-ipv6
make
make install DESTDIR=${INTERMEDIATE_INSTALL_DIR}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4: 使用 fpm 打包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fpm -s dir -t rpm -n python2.7 -v &#39;2.7.9&#39; \
    -a &#39;x86_64&#39; \
    -d &#39;openssl&#39; \
    -d &#39;bzip2&#39; \
    -d &#39;zlib&#39; \
    -d &#39;expat&#39; \
    -d &#39;db4&#39; \
    -d &#39;sqlite&#39; \
    -d &#39;ncurses&#39; \
    -d &#39;readline&#39; \
    -d &#39;zlib-devel&#39; \
    -d &#39;bzip2-devel&#39; \
    -d &#39;openssl-devel&#39; \
    -d &#39;ncurses-devel&#39;  \
    -d &#39;sqlite-devel&#39;  \
    --description=&#39;python 2.7.9 package by op&#39; \
    --directories=${INSTALL_DIR}/lib/python2.7/ \
    --directories=${INSTALL_DIR}/include/python2.7/ \
    -C ${INTERMEDIATE_INSTALL_DIR} .
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_18&#34;&gt;refer&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://theo.im/blog/2014/05/16/use-fpm-to-create-python-rpm-packages/&#34;&gt;http://theo.im/blog/2014/05/16/use-fpm-to-create-python-rpm-packages/&lt;/a&gt;
&lt;a href=&#34;https://github.com/h2oai/h2o/wiki/Installing-python-2.7-on-centos-6.3.-Follow-this-sequence-exactly-for-centos-machine-only&#34;&gt;https://github.com/h2oai/h2o/wiki/Installing-python-2.7-on-centos-6.3.-Follow-this-sequence-exactly-for-centos-machine-only&lt;/a&gt;
&lt;a href=&#34;http://toomuchdata.com/2014/02/16/how-to-install-python-on-centos/&#34;&gt;http://toomuchdata.com/2014/02/16/how-to-install-python-on-centos/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JqueryDraft</title>
      <link>http://yujinqiu.github.io/posts/JqueryDraft/</link>
      <pubDate>Sun, 11 Jan 2015 11:31:48 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/JqueryDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Jsonp&lt;/h2&gt;

&lt;p&gt;Unexpected token colon JSON after jQuery.ajax#get&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;FE 同学由于联调环境原因, 通常希望在本地调用服务端的接口, 为了解决跨域问题, 通常会使用&lt;code&gt;jsonp&lt;/code&gt;, 然后今天突然反馈说和其他 RD 联调的时候发现console log 报错:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Unexpected token :
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_2&#34;&gt;追查&lt;/h4&gt;

&lt;p&gt;开始怀疑是返回的 json 格式有问题, 利用 json 工具校验之后, 排除了这种可能性. 后面突然想到问题可能出现在 server 端,  联系相关的 RD, 看了代码之后, 发现没有提供对应的 jsonp 接口.  don&amp;rsquo;t argue, just show me the code&lt;/p&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;原因&lt;/h4&gt;

&lt;p&gt;To support &lt;a href=&#34;http://json-p.org/&#34;&gt;JSONP request&lt;/a&gt;, the server will have to include the &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Padding&lt;/code&gt;, in the response.&lt;br /&gt;
Server return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Name&amp;quot;:&amp;quot;Tome&amp;quot;, &amp;quot;Description&amp;quot;: &amp;quot;Hello it&#39;s me!&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it should be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery111108398571682628244_1403193212453({&amp;quot;Name&amp;quot;:&amp;quot;Tom&amp;quot;,&amp;quot;Description&amp;quot;:&amp;quot;Hello it&#39;s me!&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax err, &lt;code&gt;&amp;quot;Unexpected token :&amp;quot;&lt;/code&gt;, is because &lt;strong&gt;JSONP is parsed as JavaScript&lt;/strong&gt;, where  &lt;code&gt;{...}&lt;/code&gt; also represents &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&#34;&gt;blocks&lt;/a&gt;.&lt;br /&gt;
blocks syntax should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    statement_1;
    statement_2;
    ...
    statement_n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so we get &lt;code&gt;Unexpected token :&lt;/code&gt; error&lt;/p&gt;

&lt;h4 id=&#34;toc_4&#34;&gt;解决方案&lt;/h4&gt;

&lt;p&gt;在 server 端增加 JSONP 返回接口.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (callback) {
    res.setHeader(&#39;Content-Type&#39;, &#39;text/javascript&#39;); #注意这里是 javascript
    res.end(callback + &#39;(&#39; + data + &#39;)&#39;);
} else {
    res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);
    res.end(data);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AndroidDraft</title>
      <link>http://yujinqiu.github.io/posts/AndroidDraft/</link>
      <pubDate>Sat, 03 Jan 2015 13:20:13 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/AndroidDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;创建 Android Virtual Device(AVD)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android list  targets 查看已经下载好的 sdks
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;查看&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;adb devices 能够查看配置好的 android 物理设备
➜  bin git:(master) ✗ adb devices
List of devices attached
MX21CA1ALJZM4D2227  device
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;破解 Android 程序通常方法是将apk&lt;/h2&gt;

&lt;p&gt;文件利用 ApkTool反编译, 生成 Smali 格式的反汇编代码, 然后阅读 Smali 文件的代码来理解程序的运行机制, 找到突破口进行修改, 最后利用 ApkTool 重新编译生成apk 文件, 并签名, 最后进行测试&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;apktool 安装&lt;/h2&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;注意点&lt;/h3&gt;

&lt;p&gt;mac os x 利用 brew 安装之后,建议确认 apktool 的版本,使用2.0.0 以上版本, 1.5.2 版本个人测试存在问题.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;mac os x  安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Mac OS X:
    Download Mac wrapper script (Right click, Save Link As apktool)
    Download apktool-2 (find newest here)
    Rename downloaded jar to apktool.jar
    Move both files (apktool.jar &amp;amp; apktool) to /usr/local/bin (root needed)
    Make sure both files are executable (chmod +x)
    Try running apktool via cli 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note - Wrapper scripts are not needed, but helpful so you don&amp;rsquo;t have to type java -jar apktool.jar over and over.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;反编译 apk 文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;apktool d  &amp;lt;file_apk&amp;gt; -o  &amp;lt;output_dir&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_7&#34;&gt;修改反编译文件之后重新打包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;apktool  b &amp;lt;output_dir&amp;gt; 

#默认会生成在 output_dir/dist/ 下面
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_8&#34;&gt;重新签名 apk&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在签名之前需要有 keystore&lt;br /&gt;
创建 keystore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -keystore &amp;lt;name.keystore&amp;gt; -alias &amp;lt;alias_name&amp;gt; -keyalg RSA -keysize 2048 -validity 1000  
keystore:是用来存储keys 和 certificates
其中 alias_name 用来标记 key 的名称
name.keystore 是 keystore 的名称
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对 apk 进行签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name

alias_name 对应上面的创建 keystore 的名字
签名完成之后,会把签名信息直接写入 apk 文件中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证 apk 签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -verify -verbose -certs &amp;lt;name.apk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对齐 apk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk

zipalign 用来是apk 内存字节对齐, 减低内存消耗
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CN（Common Name – 名字与姓氏）：其实这个“名字与姓氏”应该是域名，比如说localhost或是blog.devep.net之类的。输成了姓名，和真正运行的时候域名不符，会出问题。浏览器访问时，弹出一个对话框，提示“安全证书上的名称无效，或者与站点名称不匹配”，用户选择继续还是可以浏览网页。但是用http client写程序访问的时候，会抛出类似于“javax.servlet.ServletException: HTTPS hostname wrong: should be ”的异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在用keytool生成数字证书时必须保证：-keystore androidapp.keystore -alias androidapp.keystore 两者名称必须相同。否则下一步签名时会出现错误：jarsigner： 找不到 androidapp.keystore 的证书链。androidapp.keystore 必须引用包含专用密钥和相应的公共密钥证书链的有效密钥库密钥条目。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;toc_9&#34;&gt;adb 重新安装 apk&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;adb install  -r &amp;lt;name.apk&amp;gt; 
-r : replace existing application
-s : install application on sdcard
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_10&#34;&gt;adb 重新安装 apk 报错和解决方案&lt;/h4&gt;

&lt;p&gt;INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
是由于破解之后的 app 的签名和编译的原apk 签名不一致导致&lt;br /&gt;
&lt;strong&gt;解决方法:&lt;/strong&gt; 删除设备或者模拟器中的 apk, 然后 再 &lt;code&gt;adb install  -r &amp;lt;name.apk&amp;gt;&lt;/code&gt; 即可&lt;/p&gt;

&lt;h4 id=&#34;toc_11&#34;&gt;android studio 常用技巧&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;command + shift + a : 输入对应的命令, 类似 alfred&lt;/li&gt;
&lt;li&gt;要修改一个控件的文件, go to definition( command + b)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MetaDraft</title>
      <link>http://yujinqiu.github.io/posts/MetaDraft/</link>
      <pubDate>Fri, 02 Jan 2015 11:31:02 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/MetaDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;如何高效学习&lt;/h2&gt;

&lt;p&gt;该内容为翻译内容, &lt;a href=&#34;http://lemire.me/blog/archives/2014/12/30/how-to-learn-efficiently/&#34;&gt;源地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我相信学校里的优等生和差生的差距是由于学习习惯导致. 坦诚的说大多数学生非常低效地学习. 更糟糕的是, 大多数老师无法传授给学生高效的学习习惯.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;学习和努力成比例&lt;/h3&gt;

&lt;p&gt;坐在教室里边听着教授演讲感觉在学习&amp;hellip;翻看一本书的一个新的话题感觉在读书&amp;hellip;但是这些行为是复杂的&lt;strong&gt;被动式活动&lt;/strong&gt;, 是低效的. 这些行为可能会导致更糟糕的结果, 它们会给你&lt;strong&gt;造成你已经学会了的假象&lt;/strong&gt;. 你可以在教室里边听关于量子力学的演讲, 在一定程度上你熟悉这个话题的和一些术语. 可悲的是你在欺骗你自己你已经学会, 这比什么都不会还要糟糕.&lt;br /&gt;
相反, 你应该给自己寻找挑战. 如果某些内容你觉得简单, 那么&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>fq</title>
      <link>http://yujinqiu.github.io/posts/FqDraft/</link>
      <pubDate>Sun, 28 Dec 2014 11:42:25 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/FqDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;FQ&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Across the Great Wall we can reach every corner of the world.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;shadowsocks (ss)&lt;/h3&gt;

&lt;h4 id=&#34;toc_2&#34;&gt;原理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;app &amp;lt;- 本地 client 解密 &amp;lt;- 墙外 vps(加密) &amp;lt;- 目标 site  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上 sshd -D 就是一个 Shadowsocks .&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -D 0.0.0.0:10086 user@vps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;注意事项&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;
ssh -D 的本质上是一个 sock5 的代理, 不是 http/https 代理, 所以在 firefox 配置里边&lt;strong&gt;不能&lt;/strong&gt;够把 HTTP Proxy 和 SSL Proxy 配置为&lt;code&gt;127.0.0.1:10086&lt;/code&gt;, 只能设置socks 代理&lt;/li&gt;
&lt;li&gt;为了避免 &lt;a href=&#34;http://en.wikipedia.org/wiki/DNS_spoofing&#34;&gt;DNS 污染&lt;/a&gt;, 建议在 firefox 中设置&lt;code&gt;Remote DNS&lt;/code&gt;, 进行远端解析&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;相关命令代理&lt;/h3&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;curl&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;--socks5-hostname &amp;lt;host[:port]&amp;gt; 
    Use the specified SOCKS5 proxy (and let the proxy resolve the hostname) 避免 DNS 污染

--socks5 &amp;lt;host[:port]&amp;gt;
    Use the specified SOCKS proxy - but resolve the hostname locally. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议在使用&lt;code&gt;curl&lt;/code&gt; 的时候习惯加上 &lt;code&gt;-v&lt;/code&gt; 这样对应 DNS污染问题很容易发现.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;直接访问(DNS 污染) 
➜  local git:(master) ✗ curl -v  www.facebook.com
* Rebuilt URL to: www.facebook.com/
* Hostname was NOT found in DNS cache

远程DNS, 防火墙直接 reset
    ➜  local git:(master) ✗ curl -v --socks5-hostname 127.0.0.1:10086 http://www.facebook.com
* Rebuilt URL to: http://www.facebook.com/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 10086 (#0)
&amp;gt; GET / HTTP/1.1
&amp;gt; User-Agent: curl/7.37.1
&amp;gt; Host: www.facebook.com
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 302 Found
&amp;lt; Location: https://www.facebook.com/
&amp;lt; Content-Type: text/html; charset=utf-8
&amp;lt; X-FB-Debug: fHuVWgR/eAX8mxPiJViAIVoy4HBehbfOkYb7ngC2xmLWoEfEwT0O+gTVFzHI4TJdzaxw8s9IGn4fzKDFN5GtmA==
&amp;lt; Date: Sun, 28 Dec 2014 06:22:56 GMT
&amp;lt; Connection: keep-alive
&amp;lt; Content-Length: 0
&amp;lt;
* Connection #0 to host www.facebook.com left intact

使用 HTTPS 访问, 正常
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BeegoDraft</title>
      <link>http://yujinqiu.github.io/posts/BeegoDraft/</link>
      <pubDate>Sat, 27 Dec 2014 20:49:46 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/BeegoDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;beego session 失效时间&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;使用 beego 进行开发过程中为了减少大家登陆时间特定设置1个月有效期, 结果发现需要经常登陆&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;原因&lt;/h3&gt;

&lt;p&gt;session 的过期失效时间由两个方面决定&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;存储sessionid 的 cookie (SessionCookieLifetime)&lt;/li&gt;
&lt;li&gt;存储在服务器端的 session 文件( SessionGCMaxLifetime 默认3600)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开始的时候只是设置了 SessionCookieLifetime, 虽然 cookie 的内容不会被删除, 但是在服务器端的 session 文件会被删除, 在代码中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ctx.Inut.Session(&amp;quot;username&amp;quot;).(string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无法获取对应的内容, 重定向到登陆页面.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CurlDraft</title>
      <link>http://yujinqiu.github.io/posts/CurlDraft/</link>
      <pubDate>Thu, 25 Dec 2014 14:13:36 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/CurlDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;CURL 有用操作&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;curl post 数据&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提交 key:value 格式数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d &#39;username=xyz&amp;amp;password=xyz&#39; http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交 json格式数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;xyz&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;xyz&amp;quot;}&#39; http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;参数内容较多,直接写入到一个文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d @param.json  http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传附件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -F &amp;quot;blob=@card.txt;type=text/plain&amp;quot; http://localhost:3000/upload
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定 curl 方法
我们在执行的时候, 需要指定 HTTP 对应的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X DELETE  &amp;lt;URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GolangDraft</title>
      <link>http://yujinqiu.github.io/posts/GolangDraft/</link>
      <pubDate>Fri, 12 Dec 2014 12:17:54 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/GolangDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Golang 相关 tools 安装&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在学习 golang 过程中, 看到 Rob Pike 大神的 &lt;a href=&#34;https://talks.golang.org/2012/waza.slide#19&#34;&gt;slide&lt;/a&gt; , 感觉炫酷.  安装过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get golang.org/x/tools/cmd/present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 如果期望手工 build, 进入目录:  &lt;code&gt;go/src/golang.org/x/tools/cmd/present&lt;/code&gt;  不要搞错.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;输出前缀为0的数字&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在运维过程中为了管理大量的机器, 通常会对机器进行编号, 比如 &lt;code&gt;web001.$idc&lt;/code&gt; &lt;code&gt;web0002.$idc&lt;/code&gt;,
在 golang 中的解决方案:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%03d&amp;quot;, seq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明:&lt;br /&gt;
%3d 表示输出数字的宽度至少为 3&lt;br /&gt;
0   填充前导的0而非空格；对于数字，这会将填充移到正负号之后&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Golang 字符串 split&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;通常我们需要对一个字符串进行 split, 通常反应是利用&lt;code&gt;strings.Split()&lt;/code&gt; 来进行切分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  s = &amp;quot;a b  c&amp;quot;
fmt.Println(&amp;quot;%#v&amp;quot;, strings.Split(s,&amp;quot; &amp;quot;))

output: 
[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;c&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出来&lt;code&gt;strings.Split()&lt;/code&gt; 只是简单的利用 SEP 来进行切分.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;解决方案&lt;/h3&gt;

&lt;p&gt;目前想到的解决方案是利用&lt;code&gt;regexp&lt;/code&gt; 来进行切分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    var s = &amp;quot;a b  c&amp;quot;
    fmt.Printf(&amp;quot;%#v\n&amp;quot;, regexp.MustCompile(&amp;quot; +&amp;quot;).Split(s, -1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Golang 时间处理&lt;/h2&gt;

&lt;p&gt;时间主要分为 date + time(gaoling 中叫 clock)&lt;/p&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;获取当前时间信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now  := time.Now()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;获取 epoch time (timestamp)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now.Unix()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;获取月份&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now.Month()
curMonth := now.Month()
if curMonth == time.June {
    ...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;获取日期部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;year, month, day := now.Date()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;获取时间部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;hour, min, sec  := now.Clock()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;获取当前时区&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fun (Time)Zone() (name string, offset int)
offset: 表示和 UTC 的时差(单位 s), 比如东八区(28800 8h)

now := time.Now()
zone, offset := now.Zone()

fmt.Println(&amp;quot;time zone:%s&amp;quot;, zone)
time zone:CST
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_14&#34;&gt;转换为 UTC 时间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func (t Time) UTC() Time
UTC returns t with the location set to UTC
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_15&#34;&gt;相对时间&lt;/h3&gt;

&lt;p&gt;时间相关还有一个问题是是&lt;strong&gt;时间间隔&lt;/strong&gt;, 比如我们需要 profile 一个函数的耗时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stime := time.Now()
expensiveCall()
time := time.Now()

var duration Duration = etime.Sub(stime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;其实本质上Duration 就是一个表示两个时刻之间的纳秒数( int64)&lt;/strong&gt;&lt;br /&gt;
其中 duration.Seconds(), duration.Minutes() 表示duration 转换为对应的秒数, 分钟, 注意 这里并不是只是获取 duration 的秒数或者分钟部分, duration 只是表示间隔, 并没有 clock 中 minutes 和 second.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stime := time.Now()
time.Sleep(3 * time.Second)
etime := time.Now()

duration :=  etime.Sub(stime)
fmt.Printf(&amp;quot;elapsed: %s minutes&amp;quot;, duration.Minutes())
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_16&#34;&gt;科普 CST 含义&lt;/h4&gt;

&lt;p&gt;CST: 中部标准时间 (Central Standard Time)
同时表示下面4个时区&lt;br /&gt;
CST Central Standard Time(USA) UT-6:00
CST Central Standard Time(Australia) UT 9:30
&lt;strong&gt;CST China Standard Time UT 8:00&lt;/strong&gt;
CST Cuba Standard Time UT-4:0&lt;br /&gt;
我们常遇到的应该就是 China Standard Time.&lt;/p&gt;

&lt;h4 id=&#34;toc_17&#34;&gt;GMT 和 UTC 的关系&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;UTC (Universal Time Coordinated), 以子午初线(经度0)上的评价太阳时为依据, 也就是英国伦敦的平均太阳时&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GMT (Greenwitch Mean Time) 格林威治平均时间, 由于地球绕太阳的运行的轨道是椭圆, 导致 UTC 表示的时间, 不是很准确, 因此提出了 GMT 时间, 每年或者2年对 UTC 增加一个闰秒, 来完成修正.  一般上我们可以认为 GMT 和 UTC 是一样的.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_18&#34;&gt;Golang 设置时区&lt;/h3&gt;

&lt;h4 id=&#34;toc_19&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;最近在给运营同学做一个定时和实时配送策略文件的时候, 遇到一个问题: 对于运营同学自然不可能要求他们会 crontab, 因此和运营同学约定设置配送格式为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File  Time
a.txt  08:30:00  #早上8点定时配送
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台程序的设计思路其实很简单, 就是通过&lt;strong&gt;对比当前时间和配置时间&lt;/strong&gt; 如果当前时间大于配置时间的话, 就采用最近的时间进行配置.&lt;/p&gt;

&lt;p&gt;发现问题是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    settingTime := &amp;quot;2015-01-11 15:04:05&amp;quot;
    t, _ := time.Parse(layout, settingTime)
    fmt.Println(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回时间如下, 也就是说默认返回的是 UTC 时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-01-11 15:04:05 +0000 UTC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用 &lt;code&gt;time.Now()&lt;/code&gt; 得到的是 &lt;code&gt;2015-01-11 22:37:03.437033928 +0800 CST&lt;/code&gt; CST 时间.&lt;br /&gt;
UTC 和 CST 的时间相差8小时, 因此为了方便运营同学配置, 需要将加载的配置时间设置为 CST.&lt;/p&gt;

&lt;h4 id=&#34;toc_20&#34;&gt;解决方案&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func StrToTime(timeStr string) (time.Time, error) {
    loc, _ := time.LoadLocation(&amp;quot;Asia/Chongqing&amp;quot;)
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    fmt.Println(&amp;quot;time star parse is : &amp;quot;, timeStr)
    return time.ParseInLocation(layout, timeStr, loc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方案2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func StrToTime(timeStr string)(time.Time, error) {
    loc := time.FixedZone(&amp;quot;CST&amp;quot;, 3600 * 8) 
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    return time.ParseInLocation(layout, timeStr, loc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_21&#34;&gt;Golang 获取文件 mtime, ctime, atime&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func statTimes(name string)(atime, ctime, time time.Time, err error) {
    fi, err := os.Stat(name)
    if err != nil {
        return 
    }
    mtime = fi.ModTime()
    stat := fi.Sys().(*syscall.Stat_t)
    atime = time.Unix(int64(stat.Atim.Sec), int64(stat.Atim.Nsec))
    ctime = time.Unix(int64(stat.Ctim.Sec), int64(stat.Ctim.Nsec))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_22&#34;&gt;Golang 多文件上传&lt;/h3&gt;

&lt;p&gt;最近计划做一个 Babel项目, 该项目解决的问题是: 办公环境和 IDC 之间由于安全问题, 封锁了网络链路, 只允许部分端口直连, 通过 rz/sz 传输代码也极其不方便, 因此系统提供一个上传和下载功能的简单工具.&lt;br /&gt;
在上传的时候希望能够支持多个文件上传, 调研了一下发现 html 里边对于多个文件上传其实有两种形式的.&lt;/p&gt;

&lt;p&gt;1: 单个上传通道, 支持多个文件上传.&lt;br /&gt;
HTML 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;uploadForm&amp;quot;  enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/upload&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;
#注意 enctype 必须为 multipart/form-data
    &amp;lt;p&amp;gt;Golang Upload&amp;lt;/p&amp;gt; &amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file1&amp;quot; name=&amp;quot;uploadFile&amp;quot; multiple /&amp;gt; #注意这里的 multiple 表明支持多个文件上传.     
    &amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Upload&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func UploadServer(w http.ResponseWriter, r *http.Request) {
    r.ParseMultiPartForm(32 &amp;lt;&amp;lt; 20) // 32M, 在使用 MultiPartForm 之前必须要先调用ParseMultiPartForm  
    if r.MultiPartForm != nil &amp;amp;&amp;amp; r.MultiPartForm.File != nil {
        fhs := r.MultiPartForm.File[&amp;quot;uploadFile&amp;quot;]

        for index, header := range fhs {
            filename := header.Filename
            file, _ := header.Open()
            defer file.Close()

            //save file to disk
            f, err := os.Create(filename)
            defer f.Close()

            io.Copy(f, file)

            fstat, _ := f.Stat()
            fmt.Fprintf(w, &amp;quot;No: %d, Size:%d KB Name:%s&amp;quot;, index, fstat.Size()/1024, filename)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多个上传通道, 本质上其实和方案一样, 差异在 HTML.
HTML 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;form action=&amp;quot;/v1/dispatch&amp;quot; method=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; class=&amp;quot;btn&amp;quot; value=&amp;quot;上传文件&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.Ctx.Request.ParseMultipartForm( 10 * (8 &amp;lt;&amp;lt; 20))
fhs := this.Ctx.Request.MultipartForm.File[&amp;quot;uploadFiles[]&amp;quot;]
var forgetMeta bool = true
var realtime bool = false


for index, f := range fhs {
    file, err := f.Open()
    defer file.Close()


    if err != nil {
        beego.Warn(&amp;quot;open file failed.&amp;quot;)
    }else{
    beego.Trace(&amp;quot;ok, I get &amp;quot;,index,&amp;quot;th file:&amp;quot;, f.Filename)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它知识点:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; options := r.MultipartForm.Value[&amp;quot;options[]&amp;quot;] #获取HTML数组内容.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果form里面变量都是唯一的，直接用parseFormValue，和parseFile就可以，因为返回的都是单个变量而不是一个数组了，省的另外操作数组。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;## Golang post https 服务
 ### 背景
 公司有一个服务是利用 https 提供服务的, 在改域名下提供一个 http 接口.  利用 curl POST&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; curl  -d &#39;name=foo&#39; https://foo.bar.com 
 提示错误: Get https://golang.org/: certificate is valid for *.appspot.com, *.*.appspot.com, appspot.com, not golang.org

 curl -d &#39;name=foo&#39; -k  https://foo.bar.com 才可以  

 -k, --insecure
          (SSL)  This option explicitly allows curl to perform &amp;quot;insecure&amp;quot; SSL connections and transfers. All SSL connections are attempted to be made secure
          by using the CA certificate bundle installed by default. This makes all connections considered &amp;quot;insecure&amp;quot; fail unless -k, --insecure is used.

          See this online resource for further details: http://curl.haxx.se/docs/sslcerts.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;golang 代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;crypto/tls&amp;quot;
)

func main() {
    transport := &amp;amp;http.Transport{
        TLSClientConfig : &amp;amp;tls.Config{InsecureSkipVerify: true},
    }

    client := &amp;amp;http.Client{Transport: transport}

    _, err := client.Get(&amp;quot;https://golang.org/&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/12122159/golang-how-to-do-a-https-request-with-bad-certificate&#34;&gt;refer&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_24&#34;&gt;Go get 工具&lt;/h2&gt;

&lt;p&gt;今天在使用第三方服务的时候, 在使用一个项目的时候, 需要获取对应的 package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go  get  ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; 命令了解, 可是有&lt;code&gt;threee dot&lt;/code&gt; 没有看到对应的文档说明, 只能阅读对应的代码. 发现原来是这样的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// downloadPaths prepares the list of paths to pass to download.
// It expands ... patterns that can be expanded.  If there is no match
// for a particular pattern, downloadPaths leaves it in the result list,
// in the hope that we can figure out the repository from the
// initial ...-free prefix.
func downloadPaths(args []string) []string {
args = importPathsNoDotExpansion(args)
var out []string
for _, a := range args {
    if strings.Contains(a, &amp;quot;...&amp;quot;) {
        var expand []string
        // Use matchPackagesInFS to avoid printing
        // warnings.  They will be printed by the
        // eventual call to importPaths instead.
        if build.IsLocalImport(a) {
            expand = matchPackagesInFS(a)
        } else {
            expand = matchPackages(a)
        }
        if len(expand) &amp;gt; 0 {
            out = append(out, expand...)
            continue
        }
    }
    out = append(out, a)
}
return out
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go get 在获取到对应的下载的 path 的时候, 对 &lt;code&gt;...&lt;/code&gt; 进行特殊处理, &lt;code&gt;...&lt;/code&gt; 作用就是&lt;strong&gt;对该目录下的所有文件进行 go get&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_25&#34;&gt;Go log 知识点&lt;/h2&gt;

&lt;p&gt;程序中输出日志其实是一件艺术的事情, 首先日志一定要有, 不然出现问题的时候就悲剧了, 根本就无从下手. 然后日志要详细但是不啰嗦. 太过啰嗦很容易导致有用的信息被淹没&lt;br /&gt;
golang 语言中自己就提供了 log 库.&lt;/p&gt;

&lt;h3 id=&#34;toc_26&#34;&gt;log 如何写入到磁盘中&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;f, err :=  os.OpenFile(logFile, os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666)
log.SetOutput(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_27&#34;&gt;日志如何设置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_28&#34;&gt;Golang 判断文件是否存在&lt;/h2&gt;

&lt;h3 id=&#34;toc_29&#34;&gt;文件存在&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if _, err := os.Stat(filename); err == nil {
    fmt.Println(&amp;quot;file exists&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_30&#34;&gt;文件不存在&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if _, err := os.Stat(filename); os.IsNotExist(err) {
    fmt.Println(&amp;quot;no such filename&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_31&#34;&gt;好奇os.IsNotExist(err) 如何获取到错误类型?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// IsNotExist returns a boolean indicating whether the error is known to
// report that a file or directory does not exist. It is satisfied by
// ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool {
    return isNotExist(err)
}
#其中 isNotExist() 是为了实现跨平台, 在 error_plan9.go 和 error_unix.go 和 error_windows.go 里边分别实现了 isNotExist. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_32&#34;&gt;Golang 函数数组&lt;/h2&gt;

&lt;h3 id=&#34;toc_33&#34;&gt;定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var farr []func()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_34&#34;&gt;定义并初始化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func do_stuff() {
    fmt.Println(&amp;quot;do silly stuff&amp;quot;)
}
var  farr []func(){do_stuff}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_35&#34;&gt;调用数组内的函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;farr[0]()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_36&#34;&gt;高阶函数( high order 函数)&lt;/h3&gt;

&lt;p&gt;所谓高阶函数其实就是一个比较特殊的函数, 该函数可以以输入函数, 返回函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func z(i int) int {
    return i * 100
}

func foo(bar func(int)int) (func(int) int) {
    base := bar(1)
    return func(y int) int {
        return x + base  //闭包   
    }
}

func main () {
    a := foo(z)
    fmt.Printf(&amp;quot;result: %v\n&amp;quot;, a(2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_37&#34;&gt;Golang 标准库&lt;/h2&gt;

&lt;p&gt;import &amp;ldquo;math/rand&amp;rdquo; , 该 package 实现伪随机数生成&lt;br /&gt;
随机数生成是通过 Source.  顶级的函数,比如 Float64 和 Int 使用的是共享的 Source 会产生&lt;strong&gt;确定性&lt;/strong&gt; 的结果,&lt;br /&gt;
我们可以使用 Seed 函数来初始化改变 Source 让其产生不同的行为.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;time&amp;quot;
        &amp;quot;math/rand&amp;quot;
       )

func main() {
    rand.Seed(time.Now().UnixNano())  
    //注意如果 Seed() 内部的随机因子是确定的数, 每次运行的随机的结果是一样.
    //曾经利用这个特性, 以每天的日期作为随机的种子进行虚拟机的数目的产生.
    fmt.Println(rand.Intn(100))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nmap Draft</title>
      <link>http://yujinqiu.github.io/posts/NmapHack/</link>
      <pubDate>Thu, 04 Dec 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/NmapHack/</guid>
      <description>

&lt;p&gt;#nmap 简单介绍&lt;/p&gt;

&lt;p&gt;本文的切入点:hacker使用Nmap的流程角度来介绍如何掌握Nmap这个强大的工具,帮助安全管理员发现自己网站的漏洞, 并逐步加固自己的安全.&lt;/p&gt;

&lt;p&gt;nmap(network mapper) 主要用途&lt;br /&gt;
- 网络发现&lt;br /&gt;
- 安全扫描
- 端口扫描
- 网络审查&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;nmap 命令选项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap [-s (Scan Type)] [Options] {target specification}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Let&amp;rsquo;s start hack&lt;/h2&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;确定网络的主机&lt;/h3&gt;

&lt;p&gt;hacker使用Nmap来扫描整个网络。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sP 192.168.1.0/24  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-sP 表示ping scanning, nmap 发送ICMP echo request 到每个机器, 返回echo response的机器是存活状态. 但是有些站点会屏蔽echo request , 因此nmap 会发送一个TCP ack packet 到端口80 (by default), 如果获取到RST, 那么也可以确定是
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;强制使用TCP ACK(PA) 或者 TCP SYN(PS) 来进行存活探测&lt;/h4&gt;

&lt;p&gt;有些机器或者firewall 会关闭&lt;strong&gt;ICMP response&lt;/strong&gt;, 我们可以强制使用&lt;strong&gt;TCP ACK&lt;/strong&gt; 或者&lt;strong&gt;TCP SYN&lt;/strong&gt;来进行扫描.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use -PA&amp;lt;port1&amp;gt;[,port2][...].  The default port is 80, since this port is often not filtered out.  Note that this option now accepts multiple, comma-separated port numbers.

nmap -PS 80,81 192.168.1.101
nmap -PA 8888,8889192.158.1.101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap ip1 ip2 ip3
nmap 192.168.1.*
nmap 192.168.1.101,102,103
nmap 191.168.1.101-201
nmap 129.168.1.101-201 --exclude=192.168.1.150  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;端口扫描&lt;/h3&gt;

&lt;p&gt;确定在子网内的机器ip之后就可以针对某些特定的机器进行端口扫描.
1: 使用TCP连接进行扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sT 192.168.1.2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;本机会利用connect() 和远程进行进行创建连接, 如果远程的机器端口是Listened, connect() 会成功  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点: 不需要root权限就能够进行
缺点: 该扫描很容易被远程机器探测到, 远程的机器会记录创建连接和错误日志.&lt;/p&gt;

&lt;p&gt;2: 隐蔽扫描(stealth scanning)
使用TCP SYN扫描来解决上面的问题, 这种方式通常叫&amp;rdquo;half-open scanning&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sS 192.168.1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;本机发送SYN, 如果端口listen那么就返回 ACK|SYN,本机收到之后返回RST来断开连接.  如果返回RST那么表示该端口没有listen. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点: half-open scanning 相对来说比较难被发现在扫描
缺点:执行该操作需要root 权限, 因为需要构建SYN包.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;防火墙检查&lt;/h3&gt;

&lt;p&gt;检查目标机器是否在防火墙或者packet filter之后?　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sA 192.168.0.101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;检测刚刚启动的host&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap -sP  192.168.1.*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;操作系统识别(OS Fingerprinting)&lt;/h3&gt;

&lt;p&gt;hacker可能对某个os的漏洞很熟悉, 能够轻易进入该操作系统的机器.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -O ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;indent 扫描&lt;/h3&gt;

&lt;p&gt;hacker 会选择一台对某些进程存在漏洞的电脑, 比如一个root运行的webserver, 如果目标机器运行了identd(前提哦,identd是一个协议的实现) 通过 &lt;code&gt;-l&lt;/code&gt;选项能够进行查看哪个用户拥有http守护进程.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sT -p 80 -l -O www.yourserver.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache运行在root下，是不安全的实践，你可以通过把/etc/indeed.conf中的&lt;strong&gt;auth服务注销&lt;/strong&gt;来阻止ident请求，并重新启动ident。另外也可用使用ipchains或你的最常用的防火墙，在网络边界上执行防火墙规则来终止ident请求，这可以阻止来路不明的人探测你的网站用户拥有哪些进程。&lt;/p&gt;

&lt;p&gt;###快速扫描
 只进行nmap-services 文件中列出的服务进行检测.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -F 192.168.1.101  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;### TCP端口扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -p -T:8888,80 192.168.1.101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;常用选项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-p 指定端口 -p 21,22,23
-v verbose mode 详细模式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;检测host 服务的版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap -sV www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;小结：　　&lt;/h3&gt;

&lt;p&gt;使用什么样的方法来抵制一个黑客使用Nmap，这样的工具是有的，比如 Scanlogd, Courtney, and Shadow;，然而使用这样的工具并不能代替网络安全管理员。因为扫描只是攻击的前期准备，站点使用它只可以进行严密的监视。 使用Nmap监视自己的站点，系统和网络管理员能发现潜在入侵者对你的系统的探测。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MysqlDraft</title>
      <link>http://yujinqiu.github.io/posts/MysqlDraft/</link>
      <pubDate>Thu, 04 Dec 2014 13:53:18 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/MysqlDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Mysql多列去重&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在项目中通常需要我们对数据进行去重, 第一反应应该是使用&lt;code&gt;distinct&lt;/code&gt; 来进行去重, 假设数据如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;monalisa&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;monalisa&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;test&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;demo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;select distinct name , age from driver; 但是很多时候我们需要保留 id

mysql&amp;gt; select distinct name , age from driver;
+----------+------+
| name     | age  |
+----------+------+
| monalisa |  100 |
| foo      |  100 |
| monalisa |   26 |
| bar      |  100 |
| test     |  100 |
| demo     |  100 |
+----------+------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用 &lt;code&gt;select distinct id, name, age from driver&lt;/code&gt; 无法实现想要的效果, 因为 distinct 看来是三元组 [id, name, age], 均不一样.&lt;/p&gt;

&lt;p&gt;可以采用 &lt;code&gt;select id, name, age from driver group by name, age&lt;/code&gt; 来实现.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Mysql 复制行&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在开发中, 经常需要初始数据, INSERT INTO &lt;TABLE&gt; values (&amp;hellip;.), (&amp;hellip;) , 效率比较慢,  我们经常需要充以后的内容中复制几行.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from driver;
+----+----------+------+
| id | name     | age  |
+----+----------+------+
|  1 | monalisa |  100 |
|  2 | foo      |  100 |
|  3 | monalisa |   26 |
|  4 | foo      |  100 |
|  5 | bar      |  100 |
|  6 | test     |  100 |
|  7 | demo     |  100 |
+----+----------+------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我们需要复制 monalisa 行到新行里边, 然后就可以修改新行内容.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert into driver (name, age) select name,  age from driver where name = &#39;monalisa&#39; ; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Mysql 输出取消 table 内容&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;我们在 Mysql 查询内容的时候, 为方便数据处理, 有时候我们不需要输出结果中带有 table 边框.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-s, --silent        Be more silent. Print results with a tab as separator,
                  each row on new line.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Mysql 异常&lt;/h2&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;1290 the mysql server is running with the read-only option&lt;/h3&gt;

&lt;p&gt;1: 确认权限问题&lt;br /&gt;
2: show variables like &amp;lsquo;%read_only%&amp;lsquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Variable_name  Value
read_only       On #这里应该为 OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3: 设置 read_only = off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set GLOBAL read_only = false;  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AppleDraft</title>
      <link>http://yujinqiu.github.io/posts/Apple/</link>
      <pubDate>Tue, 25 Nov 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/Apple/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Apple&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;iphone 屏幕小白点怎么开启?&lt;/h2&gt;

&lt;p&gt;看到别人的屏幕有一个小白点, 点击之后出现siri, device, favorites 和 home 怎么打开?&lt;br /&gt;
那个东西叫Assistive Touch , 在 /setting/general/Accessibility/AssistiveTouch 里边可以打开.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;iphone越狱&lt;/h2&gt;

&lt;p&gt;其实不想一开始就写这篇文章,实在受不了美国v版的中文输入法, 就动起了越狱的心思.网上看了有什么pp助手,91助手之类的工具, 本着对国内流氓公司的不信任的关系,另外恰巧在安装&lt;a href=&#34;http://justgetflux.com/&#34;&gt;f.lux&lt;/a&gt; 遇到&lt;a href=&#34;http://evasi0n.com/&#34;&gt;破解的说明&lt;/a&gt;, 具体操作说明很清楚不到10min就越狱完成. 需要注意点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;越狱前强烈建议利用itunes来进行完整备份&lt;/li&gt;
&lt;li&gt;关闭passcode功能&lt;/li&gt;
&lt;li&gt;退出所有的应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Draft</title>
      <link>http://yujinqiu.github.io/posts/GitDraft/</link>
      <pubDate>Tue, 25 Nov 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/GitDraft/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Git&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;原子提交&lt;/h2&gt;

&lt;p&gt;在我们修改文件的时候, 通常是希望一次提交只包含该次功能修改相关的操作.&lt;br /&gt;
但是如果一个文件包含多个操作该怎么办 ?&lt;br /&gt;
或者你的一个程序文件里边,为了调试写了很多的log日志输出, 你不希望这些语句ci 到server上, 该怎么办 ?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git add -p&lt;/code&gt; 能够解决上面的场景(虽然已经add 过,还是需要add 到 stage 进去).&lt;br /&gt;
执行之后会提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stage this hunk [y,n,q,a,d,/,e,?]?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hit &lt;code&gt;s&lt;/code&gt; to split whatever change into smaller chunks. This only works if there is at least one unchanged line in the &amp;ldquo;middle&amp;rdquo; of the hunk, which is where hunk will be split&lt;br /&gt;
then hit &lt;code&gt;y&lt;/code&gt; to stage that chunk&lt;br /&gt;
or &lt;code&gt;n&lt;/code&gt; to not stage that hunk&lt;br /&gt;
or &lt;code&gt;e&lt;/code&gt; to manually edit the chunk (useful when git can&amp;rsquo;t split it automatically)&lt;br /&gt;
and &lt;code&gt;d&lt;/code&gt; to exit or go to the next file.&lt;br /&gt;
Use &lt;code&gt;?&lt;/code&gt; to get the whole list of available options.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Git checkout 某个分支&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在使用 git 的时候, 经常会使用第三方开发的程序/lib 的特定版本(兼容性问题) ,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag -l
git checkout tags/&amp;lt;tag_name&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Git checkout 远程的一个分支&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在多人协作的开发场景下, Dev B 提交了一个分支, 需要拉到本地.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git fetch origin 
git branch -v -a 
git checkout -b test origin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Git 多人开发流程&lt;/h2&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;如何发 PR&lt;/h3&gt;

&lt;p&gt;以下以 wiki-pages 为例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把项目 fork 到自己名下，然后 clone 到本地&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@git.xiaojukeji.com:yexiliang/wiki-pages.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将原始项目加为上游&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add upstream git@git.xiaojukeji.com:op/wiki-pages.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在本地项目建立分支并切换到该分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b dev
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 dev 分支上开发，提交&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch foo.txt
git add foo.txt
git commit
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换到 master 分支并合并上游&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout master
git fetch upstream
git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换到 dev 分支，合并 master，推送代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout dev
git rebase master
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到 github / gitlab 选 dev 分支发 pull request&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Git conflict 如何保持一方修改&lt;/h2&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在多人协作的情况下, 经常会出现冲突, 有时候不想 merge conflict, 直接使用双方的修改内容.&lt;/p&gt;

&lt;h4 id=&#34;toc_10&#34;&gt;保持本地修改, 放弃远程版本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;git checkout --ours filename.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_11&#34;&gt;使用远程版本, 放弃本地修改&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;git checkout --theirs filename.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Git 回滚到上一个版本&lt;/h2&gt;

&lt;p&gt;作为项目的负责人, 通过 code review 并不能保证其中提交内容ok, 如果出现异常, 需要仅限回滚.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;branch1    branch2
    \        /
     \      /
      \    /
       \  /
       new branch (hashcode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设用户提交的 branch2  有问题, 需要回滚回 branch1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git  revert  -m 1  hashcode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何得到 &lt;code&gt;-m&lt;/code&gt; 之后对应的 branch  是  1 ? 2 ?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/go/src/ServiceTree$ git show af24b57a530adcf24d098676809bc88939336063  
commit af24b57a530adcf24d098676809bc88939336063  
Merge: 609bb8e d160c3f   #注意这里
Date:   Sat Dec 27 11:30:37 2014 +0800   

Merge branch &#39;dev&#39; of ssh://git.xiaojukeji.com:22/op/servicetree into dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从 Merge 中可以选择 &lt;code&gt;-m&lt;/code&gt; 对应的选项.&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Git 删除远程 repo 文件, 保留本地文件&lt;/h2&gt;

&lt;h3 id=&#34;toc_14&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在项目开发过程中, 有一个策略文件, 由于经常需要变更不太适合进入 repo, 最开始的时候没有考虑清楚提交进去,  现在需要从远程 repo 删除, 但是需要保留本地文件, 因为项目运行需要依赖这个文件.&lt;/p&gt;

&lt;h3 id=&#34;toc_15&#34;&gt;解决方案&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git rm --cached  FILE
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_16&#34;&gt;Tortoise Git 免密码 Push 问题&lt;/h2&gt;

&lt;h3 id=&#34;toc_17&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;和 FE 同学进行合作, 为了提高协同工作的效率, 开始手把手教 FE 同学使用 Git, 其中为了避免 FE 同学在 git clone 和 push 的时候输入密码, 使用 Puttygen 生成对应的公钥和私钥对, 开始的时候一切都 ok.&lt;br /&gt;
第二天 FE 同学反馈说需要输入密码. 考虑到 FE 同学进行重启, 将问题怀疑在ssh-agent 没有启动, search 之后, 常见的方案是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval `ssh-agent -s` 
ssh-add  $&amp;lt;path_to_private_key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现没有效果.   继续 search 之后, 发现Puttygen 上面居然有一个 Pagent, 看名字应该是这个东西.  然后启动之后, 居然没有弹出窗体, 难道没有启动? 继续执行, 提示已经 running. WTF!!!. 无意间想到, 可能在 系统托盘(system tray)里边, 找到之后, 右键直接 add key 之后一切 ok.&lt;/p&gt;

&lt;h2 id=&#34;toc_18&#34;&gt;Git tag&lt;/h2&gt;

&lt;h3 id=&#34;toc_19&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在使用git的过程中, 我们通常喜欢利用 tag 来进行标记, 进行发布.&lt;/p&gt;

&lt;h3 id=&#34;toc_20&#34;&gt;How to&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git tag -a  v1.0.0 #会提示对应输入, 要求输入 annotation
git tag -l -n3  #注意-n 和 3 之间不能有空格. 
# three lines of message for every tag
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_21&#34;&gt;Git hook&lt;/h2&gt;

&lt;p&gt;Git hooks are event-based. When you run certain git commands, the software will check the &lt;strong&gt;hooks directory&lt;/strong&gt; within the git repository to see if there is an associated script to run.&lt;/p&gt;

&lt;p&gt;Some scripts run prior to an action taking place(pre-hook), which can be used to ensure code compliance to standars, for sanity checking, or to set up an environment.  Other scripts run after an event(post-hook) in order to deploy code, re-establish correct permissions, and so forth.&lt;/p&gt;

&lt;p&gt;git hook 分为 client-side hook 和  server side hook.&lt;/p&gt;

&lt;h3 id=&#34;toc_22&#34;&gt;client-side hook&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Committing-Workflow hooks: commiting hooks are used to dictate actions that should be taken around when a commit is being made.  They are used to run sanity checks, pre-populate commit messages, and verify message details. You can also use this to provide notifications upon committing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Email Workflow hooks: This category of hooks encompasses actions that are taken when working with emailed patches. Projects like the Linux kernel submit and review patches using an email method. These are in a similar vein as the commit hooks, but can be used by maintainers who are responsible for applying submitted code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Other: Other client-side hooks include hooks that execute when merging, checking out code, rebasing, rewriting, and cleaning repos.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;server-side hook&lt;/h3&gt;

&lt;p&gt;钩子在 server 端运行&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pre-receive and post-receive: These are executed on the server receiving a push to do things like check for project conformance and to deploy after a push.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Update: This is like a pre-receive, but operates on a branch-by-branch basis to execute code prior to each branch being accepted.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>