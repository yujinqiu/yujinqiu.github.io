<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on Engineer&#39;s Draft </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://yujinqiu.github.io/posts/index.xml/</link>
    
    
    
    <updated>Mon, 02 Feb 2015 20:30:22 CST</updated>
    
    <item>
      <title>BigDataDraft</title>
      <link>http://yujinqiu.github.io/posts/BigDataDraft/</link>
      <pubDate>Mon, 02 Feb 2015 20:30:22 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/BigDataDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;hbase 查看master&lt;/h2&gt;

&lt;p&gt;hbase master 信息存储在zookeeper 中, 可以在 zookeeper 中查询.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zkCli.sh -server myzoo  get  /hbase/master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;如何启动 hmaster/regionserver&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hbase-daemon.sh start master #hmaster, stop 同理
hbase-daemon.sh start regionserver #regionserver, stop 同理
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;start master 和 ./bin/start-hbase.sh 有啥区别?&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hbase-daemon.sh start master 是用来启动单个 master
./bin/start-hbase.sh 会启动整个集群, 其中会读取 hbase-0.96.2-hadoop1/conf/regionservers 用来标记 regionservers 的列表, 扩容的时候不一定需要添加进去, 因为 regionserver 的机器存储在 zookeeper.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PatternDraft</title>
      <link>http://yujinqiu.github.io/posts/PatternDraft/</link>
      <pubDate>Sun, 01 Feb 2015 13:01:41 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/PatternDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;It&amp;rsquo;s just pattern and art&lt;/h2&gt;

&lt;p&gt;工程性项目其实基本上都是固定模式的组合, 比如设计模式其实就是对编程世界的各种招式的拆解成为定式, 之所以又可以成为 art, 在于组合.  组合带来多样性和复杂性. 不同的人组合不同, favor 也不同, 然后相同 favor 的人一起组成一个 group, 然后就有派系之争.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;CRC32&lt;/h2&gt;

&lt;p&gt;经常我们期望将一个字符串转换为一个数值, 用来进行分流.  最开始自己实现的时候利用了简单的思想 将字符的 ascii 进行 sum, 上周在听 codis 分享的时候, 发现codis 利用了 CRC32算法.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FPMDraft</title>
      <link>http://yujinqiu.github.io/posts/FPMDraft/</link>
      <pubDate>Wed, 21 Jan 2015 00:08:20 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/FPMDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;FPM&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;FPM 入门&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fpm -s &amp;lt;source type&amp;gt; -t &amp;lt;target type&amp;gt; [options]
source types:  
    &amp;quot;dir&amp;quot;  可以是文件或者是目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;常见问题和解决思路&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Process failed: rpmbuild failed (exit code 1).
解决思路:  fpm 运行增加 &lt;code&gt;--verbose&lt;/code&gt; 选项, 查看日志输出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何把我的一个程序, 比如 jq 打包为 RPM 格式文件, 期望安装之后安装 到 &lt;code&gt;/bin&lt;/code&gt; 目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fpm -s dir -t rpm -n jq -v 1.4.0 --prefix=/bin/  jq


http://golang-basic.blogspot.jp/2014/10/dynamic-programming-problem-maximum.html  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;fpm 制定 package 依赖&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fpm -s dir -t rpm -n langley_online -v 1.0.0 -d &#39;thrift &amp;gt;= 0.9.1&#39; -d &#39;boost &amp;gt;= 1.41.0&#39; -d &#39;libevent &amp;gt;= 2.0.21&#39; -d &#39;fastbit &amp;gt;= 2.0.1&#39; --prefix=/home/&amp;lt;user&amp;gt;   --after-install=langley_online/install/install_hook.sh langley_online
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;如何打包 C/C++ 项目&lt;/h3&gt;

&lt;p&gt;c/c++ 项目中比较讨厌的是项目的依赖, 为了提高开发效率需要将各种依赖包打包为 RPM, 最开始一直想不明白的是, 如果我 make &amp;amp;&amp;amp; make install 之后就 pack 了, 那么如何pack呢 ?   直到今天多管闲事帮同事打包thrift之后才知道 how.&lt;/p&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;How&lt;/h4&gt;

&lt;p&gt;答案其实很简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make
make install DESTDIR=&amp;lt;dir&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般正常情况下, 会在&lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 下面生成 usr 目录, 然后利用 fpm 直接进入 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 进行打包, 指定&lt;code&gt;prefix=/&lt;/code&gt; 即可.&lt;br /&gt;
仔细思考之后, 其实 fpm 在使用 &lt;code&gt;-s dir&lt;/code&gt; 的时候的本质, 就是pack 整个包, 因此可以推断在 &lt;code&gt;./configure --prefix=&amp;lt;dir&amp;gt;&lt;/code&gt; 应该也是可以的.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;如何打包 python module&lt;/h3&gt;

&lt;p&gt;Q: 我是 python 党, 用 pip 安装 python 的各种包好方便, but 线上没有访问外网权限, 怎么破?&lt;br /&gt;
A: 为了安全线上只有部分机器可以访问外网, 因此除非你在内网搭建一个代理, 然后 pip 通过流量到 pip.  好消息是强大的 FPM 可以把python 的 pip 包打成 RPM.   python 的 thrift module 为例.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [root@svn02 ~]# fpm -s python -t rpm -a x86_64  thrift
 no value for epoch is set, defaulting to nil {:level=&amp;gt;:warn}
 no value for epoch is set, defaulting to nil {:level=&amp;gt;:warn}
 Created package {:path=&amp;gt;&amp;quot;python-thrift-0.9.2-1.x86_64.rpm&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数详解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-s INPUT_TYPE                 the package type to use as input (gem, rpm, python, etc)  
-t OUTPUT_TYPE                the type of package you want to create (deb, rpm, solaris, etc)
-a, --architecture ARCHITECTURE The architecture name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应 python module, fpm 会自动下载对应的 package, 因此只需要指定 thrift 即可.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;查看安装 pkg 详情&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rpm -q &amp;lt;pkg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@10.223.21.205:~# rpm -q thrift
thrift-0.9.2-1.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;yum 如何查看一个 rpm pkg 的详情&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum info  &amp;lt;pkg&amp;gt; 
yum list  &amp;lt;pkg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;yum 制定安装特定版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install &amp;lt;package name&amp;gt;-&amp;lt;version info&amp;gt;.&amp;lt;release info&amp;gt;.&amp;lt;architecture&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install httpd
sudo yum install httpd-2.4.6-6
sudo yum install httpd-2.4.6-6.fc20
sudo yum install httpd-2.4.6-6.fc20.x84_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;下载 rpm 包, 然后手动进行安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yumdownloader --resolve &amp;lt;package&amp;gt;
yum localinstall &amp;lt;path to rpm&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;yum 取消安装操作&lt;/h3&gt;

&lt;h4 id=&#34;toc_12&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;最近有一个glibc 安全漏洞, 安全组同学要求进行升级, 利用 yum 升级之后, 发现坑爹有问题, 需要进行回滚. 可是 glibc 依赖 package 太多, &lt;code&gt;yum downgrade pkg1.rpm pkg2.rpm ...&lt;/code&gt; 会累死人.&lt;br /&gt;
终于发现必杀技:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum history #查看历史列表

ID     | Command line             | Date and time    | Action(s)      | Altered
-------------------------------------------------------------------------------
120 | install glibc            | 2014-08-26 09:19 | Install        |    5   
yum history  undo  120 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;fpm 解决 gem 依赖问题&lt;/h3&gt;

&lt;h4 id=&#34;toc_14&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;公司有同事需要在自己的公司上的一台服务器利用 fpm 进行打包, 原来其实可以通过以下命令进行安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install ruby-devel gcc
gem install fpm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当是在想为什么不用 fpm self-bootstrap, 利用 fpm pack 自己呢.&lt;/p&gt;

&lt;p&gt;开始简单以为, 就 ok&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fpm -s gem  -t rpm  fpm 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果发现自己想简单了, fpm 底层还有各种依赖. 后面通过以下方案解决:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /tmp/gems
gem install --no-ri --no-rdoc --install-dir /tmp/gems fpm 
find /tmp/gems/cache -name &#39;*.gem&#39; | xargs -rn1 fpm -d ruby -d rubygems --prefix /usr/lib/ruby/gems/1.8 -s gem -t rpm 
然后将  生成的 rpm 放到 repo server 里边, 建立索引即可.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;--prefix&lt;/code&gt; 指的是 gem 的 &lt;code&gt;INSTALLATION DIRECTORY&lt;/code&gt; 可以通过以下方式获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@10.223.21.205:~# gem env | grep INSTALL
- INSTALLATION DIRECTORY: /usr/lib/ruby/gems/1.8
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JqueryDraft</title>
      <link>http://yujinqiu.github.io/posts/JqueryDraft/</link>
      <pubDate>Sun, 11 Jan 2015 11:31:48 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/JqueryDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Jsonp&lt;/h2&gt;

&lt;p&gt;Unexpected token colon JSON after jQuery.ajax#get&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;FE 同学由于联调环境原因, 通常希望在本地调用服务端的接口, 为了解决跨域问题, 通常会使用&lt;code&gt;jsonp&lt;/code&gt;, 然后今天突然反馈说和其他 RD 联调的时候发现console log 报错:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Unexpected token :
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_2&#34;&gt;追查&lt;/h4&gt;

&lt;p&gt;开始怀疑是返回的 json 格式有问题, 利用 json 工具校验之后, 排除了这种可能性. 后面突然想到问题可能出现在 server 端,  联系相关的 RD, 看了代码之后, 发现没有提供对应的 jsonp 接口.  don&amp;rsquo;t argue, just show me the code&lt;/p&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;原因&lt;/h4&gt;

&lt;p&gt;To support &lt;a href=&#34;http://json-p.org/&#34;&gt;JSONP request&lt;/a&gt;, the server will have to include the &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Padding&lt;/code&gt;, in the response.&lt;br /&gt;
Server return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Name&amp;quot;:&amp;quot;Tome&amp;quot;, &amp;quot;Description&amp;quot;: &amp;quot;Hello it&#39;s me!&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it should be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery111108398571682628244_1403193212453({&amp;quot;Name&amp;quot;:&amp;quot;Tom&amp;quot;,&amp;quot;Description&amp;quot;:&amp;quot;Hello it&#39;s me!&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax err, &lt;code&gt;&amp;quot;Unexpected token :&amp;quot;&lt;/code&gt;, is because &lt;strong&gt;JSONP is parsed as JavaScript&lt;/strong&gt;, where  &lt;code&gt;{...}&lt;/code&gt; also represents &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block&#34;&gt;blocks&lt;/a&gt;.&lt;br /&gt;
blocks syntax should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    statement_1;
    statement_2;
    ...
    statement_n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so we get &lt;code&gt;Unexpected token :&lt;/code&gt; error&lt;/p&gt;

&lt;h4 id=&#34;toc_4&#34;&gt;解决方案&lt;/h4&gt;

&lt;p&gt;在 server 端增加 JSONP 返回接口.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (callback) {
    res.setHeader(&#39;Content-Type&#39;, &#39;text/javascript&#39;); #注意这里是 javascript
    res.end(callback + &#39;(&#39; + data + &#39;)&#39;);
} else {
    res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);
    res.end(data);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AndroidDraft</title>
      <link>http://yujinqiu.github.io/posts/AndroidDraft/</link>
      <pubDate>Sat, 03 Jan 2015 13:20:13 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/AndroidDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;创建 Android Virtual Device(AVD)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android list  targets 查看已经下载好的 sdks
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;查看&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;adb devices 能够查看配置好的 android 物理设备
➜  bin git:(master) ✗ adb devices
List of devices attached
MX21CA1ALJZM4D2227  device
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;破解 Android 程序通常方法是将apk&lt;/h2&gt;

&lt;p&gt;文件利用 ApkTool反编译, 生成 Smali 格式的反汇编代码, 然后阅读 Smali 文件的代码来理解程序的运行机制, 找到突破口进行修改, 最后利用 ApkTool 重新编译生成apk 文件, 并签名, 最后进行测试&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;apktool 安装&lt;/h2&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;注意点&lt;/h3&gt;

&lt;p&gt;mac os x 利用 brew 安装之后,建议确认 apktool 的版本,使用2.0.0 以上版本, 1.5.2 版本个人测试存在问题.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;mac os x  安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Mac OS X:
    Download Mac wrapper script (Right click, Save Link As apktool)
    Download apktool-2 (find newest here)
    Rename downloaded jar to apktool.jar
    Move both files (apktool.jar &amp;amp; apktool) to /usr/local/bin (root needed)
    Make sure both files are executable (chmod +x)
    Try running apktool via cli 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note - Wrapper scripts are not needed, but helpful so you don&amp;rsquo;t have to type java -jar apktool.jar over and over.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;反编译 apk 文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;apktool d  &amp;lt;file_apk&amp;gt; -o  &amp;lt;output_dir&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_7&#34;&gt;修改反编译文件之后重新打包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;apktool  b &amp;lt;output_dir&amp;gt; 

#默认会生成在 output_dir/dist/ 下面
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_8&#34;&gt;重新签名 apk&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在签名之前需要有 keystore&lt;br /&gt;
创建 keystore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -keystore &amp;lt;name.keystore&amp;gt; -alias &amp;lt;alias_name&amp;gt; -keyalg RSA -keysize 2048 -validity 1000  
keystore:是用来存储keys 和 certificates
其中 alias_name 用来标记 key 的名称
name.keystore 是 keystore 的名称
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对 apk 进行签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name

alias_name 对应上面的创建 keystore 的名字
签名完成之后,会把签名信息直接写入 apk 文件中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证 apk 签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -verify -verbose -certs &amp;lt;name.apk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对齐 apk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk

zipalign 用来是apk 内存字节对齐, 减低内存消耗
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CN（Common Name – 名字与姓氏）：其实这个“名字与姓氏”应该是域名，比如说localhost或是blog.devep.net之类的。输成了姓名，和真正运行的时候域名不符，会出问题。浏览器访问时，弹出一个对话框，提示“安全证书上的名称无效，或者与站点名称不匹配”，用户选择继续还是可以浏览网页。但是用http client写程序访问的时候，会抛出类似于“javax.servlet.ServletException: HTTPS hostname wrong: should be ”的异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在用keytool生成数字证书时必须保证：-keystore androidapp.keystore -alias androidapp.keystore 两者名称必须相同。否则下一步签名时会出现错误：jarsigner： 找不到 androidapp.keystore 的证书链。androidapp.keystore 必须引用包含专用密钥和相应的公共密钥证书链的有效密钥库密钥条目。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;toc_9&#34;&gt;adb 重新安装 apk&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;adb install  -r &amp;lt;name.apk&amp;gt; 
-r : replace existing application
-s : install application on sdcard
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_10&#34;&gt;adb 重新安装 apk 报错和解决方案&lt;/h4&gt;

&lt;p&gt;INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
是由于破解之后的 app 的签名和编译的原apk 签名不一致导致&lt;br /&gt;
&lt;strong&gt;解决方法:&lt;/strong&gt; 删除设备或者模拟器中的 apk, 然后 再 &lt;code&gt;adb install  -r &amp;lt;name.apk&amp;gt;&lt;/code&gt; 即可&lt;/p&gt;

&lt;h4 id=&#34;toc_11&#34;&gt;android studio 常用技巧&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;command + shift + a : 输入对应的命令, 类似 alfred&lt;/li&gt;
&lt;li&gt;要修改一个控件的文件, go to definition( command + b)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MetaDraft</title>
      <link>http://yujinqiu.github.io/posts/MetaDraft/</link>
      <pubDate>Fri, 02 Jan 2015 11:31:02 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/MetaDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;如何高效学习&lt;/h2&gt;

&lt;p&gt;该内容为翻译内容, &lt;a href=&#34;http://lemire.me/blog/archives/2014/12/30/how-to-learn-efficiently/&#34;&gt;源地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我相信学校里的优等生和差生的差距是由于学习习惯导致. 坦诚的说大多数学生非常低效地学习. 更糟糕的是, 大多数老师无法传授给学生高效的学习习惯.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;学习和努力成比例&lt;/h3&gt;

&lt;p&gt;坐在教室里边听着教授演讲感觉在学习&amp;hellip;翻看一本书的一个新的话题感觉在读书&amp;hellip;但是这些行为是复杂的&lt;strong&gt;被动式活动&lt;/strong&gt;, 是低效的. 这些行为可能会导致更糟糕的结果, 它们会给你&lt;strong&gt;造成你已经学会了的假象&lt;/strong&gt;. 你可以在教室里边听关于量子力学的演讲, 在一定程度上你熟悉这个话题的和一些术语. 可悲的是你在欺骗你自己你已经学会, 这比什么都不会还要糟糕.&lt;br /&gt;
相反, 你应该给自己寻找挑战. 如果某些内容你觉得简单, 那么&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>fq</title>
      <link>http://yujinqiu.github.io/posts/FqDraft/</link>
      <pubDate>Sun, 28 Dec 2014 11:42:25 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/FqDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;FQ&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Across the Great Wall we can reach every corner of the world.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;shadowsocks (ss)&lt;/h3&gt;

&lt;h4 id=&#34;toc_2&#34;&gt;原理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;app &amp;lt;- 本地 client 解密 &amp;lt;- 墙外 vps(加密) &amp;lt;- 目标 site  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上 sshd -D 就是一个 Shadowsocks .&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -D 0.0.0.0:10086 user@vps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;注意事项&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;
ssh -D 的本质上是一个 sock5 的代理, 不是 http/https 代理, 所以在 firefox 配置里边&lt;strong&gt;不能&lt;/strong&gt;够把 HTTP Proxy 和 SSL Proxy 配置为&lt;code&gt;127.0.0.1:10086&lt;/code&gt;, 只能设置socks 代理&lt;/li&gt;
&lt;li&gt;为了避免 &lt;a href=&#34;http://en.wikipedia.org/wiki/DNS_spoofing&#34;&gt;DNS 污染&lt;/a&gt;, 建议在 firefox 中设置&lt;code&gt;Remote DNS&lt;/code&gt;, 进行远端解析&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;相关命令代理&lt;/h3&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;curl&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;--socks5-hostname &amp;lt;host[:port]&amp;gt; 
    Use the specified SOCKS5 proxy (and let the proxy resolve the hostname) 避免 DNS 污染

--socks5 &amp;lt;host[:port]&amp;gt;
    Use the specified SOCKS proxy - but resolve the hostname locally. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议在使用&lt;code&gt;curl&lt;/code&gt; 的时候习惯加上 &lt;code&gt;-v&lt;/code&gt; 这样对应 DNS污染问题很容易发现.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;直接访问(DNS 污染) 
➜  local git:(master) ✗ curl -v  www.facebook.com
* Rebuilt URL to: www.facebook.com/
* Hostname was NOT found in DNS cache

远程DNS, 防火墙直接 reset
    ➜  local git:(master) ✗ curl -v --socks5-hostname 127.0.0.1:10086 http://www.facebook.com
* Rebuilt URL to: http://www.facebook.com/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 10086 (#0)
&amp;gt; GET / HTTP/1.1
&amp;gt; User-Agent: curl/7.37.1
&amp;gt; Host: www.facebook.com
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 302 Found
&amp;lt; Location: https://www.facebook.com/
&amp;lt; Content-Type: text/html; charset=utf-8
&amp;lt; X-FB-Debug: fHuVWgR/eAX8mxPiJViAIVoy4HBehbfOkYb7ngC2xmLWoEfEwT0O+gTVFzHI4TJdzaxw8s9IGn4fzKDFN5GtmA==
&amp;lt; Date: Sun, 28 Dec 2014 06:22:56 GMT
&amp;lt; Connection: keep-alive
&amp;lt; Content-Length: 0
&amp;lt;
* Connection #0 to host www.facebook.com left intact

使用 HTTPS 访问, 正常
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BeegoDraft</title>
      <link>http://yujinqiu.github.io/posts/BeegoDraft/</link>
      <pubDate>Sat, 27 Dec 2014 20:49:46 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/BeegoDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;beego session 失效时间&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;使用 beego 进行开发过程中为了减少大家登陆时间特定设置1个月有效期, 结果发现需要经常登陆&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;原因&lt;/h3&gt;

&lt;p&gt;session 的过期失效时间由两个方面决定&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;存储sessionid 的 cookie (SessionCookieLifetime)&lt;/li&gt;
&lt;li&gt;存储在服务器端的 session 文件( SessionGCMaxLifetime 默认3600)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开始的时候只是设置了 SessionCookieLifetime, 虽然 cookie 的内容不会被删除, 但是在服务器端的 session 文件会被删除, 在代码中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ctx.Inut.Session(&amp;quot;username&amp;quot;).(string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无法获取对应的内容, 重定向到登陆页面.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CurlDraft</title>
      <link>http://yujinqiu.github.io/posts/CurlDraft/</link>
      <pubDate>Thu, 25 Dec 2014 14:13:36 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/CurlDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;CURL 有用操作&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;curl post 数据&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提交 key:value 格式数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d &#39;username=xyz&amp;amp;password=xyz&#39; http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交 json格式数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;xyz&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;xyz&amp;quot;}&#39; http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;参数内容较多,直接写入到一个文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -d @param.json  http://localhost:3000/api/login
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传附件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -F &amp;quot;blob=@card.txt;type=text/plain&amp;quot; http://localhost:3000/upload
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定 curl 方法
我们在执行的时候, 需要指定 HTTP 对应的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X DELETE  &amp;lt;URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GolangDraft</title>
      <link>http://yujinqiu.github.io/posts/GolangDraft/</link>
      <pubDate>Fri, 12 Dec 2014 12:17:54 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/GolangDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Golang 相关 tools 安装&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在学习 golang 过程中, 看到 Rob Pike 大神的 &lt;a href=&#34;https://talks.golang.org/2012/waza.slide#19&#34;&gt;slide&lt;/a&gt; , 感觉炫酷.  安装过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get golang.org/x/tools/cmd/present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 如果期望手工 build, 进入目录:  &lt;code&gt;go/src/golang.org/x/tools/cmd/present&lt;/code&gt;  不要搞错.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;输出前缀为0的数字&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在运维过程中为了管理大量的机器, 通常会对机器进行编号, 比如 &lt;code&gt;web001.$idc&lt;/code&gt; &lt;code&gt;web0002.$idc&lt;/code&gt;,
在 golang 中的解决方案:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%03d&amp;quot;, seq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明:&lt;br /&gt;
%3d 表示输出数字的宽度至少为 3&lt;br /&gt;
0   填充前导的0而非空格；对于数字，这会将填充移到正负号之后&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Golang 字符串 split&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;通常我们需要对一个字符串进行 split, 通常反应是利用&lt;code&gt;strings.Split()&lt;/code&gt; 来进行切分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  s = &amp;quot;a b  c&amp;quot;
fmt.Println(&amp;quot;%#v&amp;quot;, strings.Split(s,&amp;quot; &amp;quot;))

output: 
[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;c&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出来&lt;code&gt;strings.Split()&lt;/code&gt; 只是简单的利用 SEP 来进行切分.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;解决方案&lt;/h3&gt;

&lt;p&gt;目前想到的解决方案是利用&lt;code&gt;regexp&lt;/code&gt; 来进行切分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    var s = &amp;quot;a b  c&amp;quot;
    fmt.Printf(&amp;quot;%#v\n&amp;quot;, regexp.MustCompile(&amp;quot; +&amp;quot;).Split(s, -1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Golang 时间处理&lt;/h2&gt;

&lt;p&gt;时间主要分为 date + time(gaoling 中叫 clock)&lt;/p&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;获取当前时间信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now  := time.Now()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;获取 epoch time (timestamp)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now.Unix()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;获取月份&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;now.Month()
curMonth := now.Month()
if curMonth == time.June {
    ...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;获取日期部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;year, month, day := now.Date()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;获取时间部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;hour, min, sec  := now.Clock()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;获取当前时区&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fun (Time)Zone() (name string, offset int)
offset: 表示和 UTC 的时差(单位 s), 比如东八区(28800 8h)

now := time.Now()
zone, offset := now.Zone()

fmt.Println(&amp;quot;time zone:%s&amp;quot;, zone)
time zone:CST
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_14&#34;&gt;转换为 UTC 时间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func (t Time) UTC() Time
UTC returns t with the location set to UTC
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_15&#34;&gt;相对时间&lt;/h3&gt;

&lt;p&gt;时间相关还有一个问题是是&lt;strong&gt;时间间隔&lt;/strong&gt;, 比如我们需要 profile 一个函数的耗时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stime := time.Now()
expensiveCall()
time := time.Now()

var duration Duration = etime.Sub(stime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;其实本质上Duration 就是一个表示两个时刻之间的纳秒数( int64)&lt;/strong&gt;&lt;br /&gt;
其中 duration.Seconds(), duration.Minutes() 表示duration 转换为对应的秒数, 分钟, 注意 这里并不是只是获取 duration 的秒数或者分钟部分, duration 只是表示间隔, 并没有 clock 中 minutes 和 second.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stime := time.Now()
time.Sleep(3 * time.Second)
etime := time.Now()

duration :=  etime.Sub(stime)
fmt.Printf(&amp;quot;elapsed: %s minutes&amp;quot;, duration.Minutes())
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_16&#34;&gt;科普 CST 含义&lt;/h4&gt;

&lt;p&gt;CST: 中部标准时间 (Central Standard Time)
同时表示下面4个时区&lt;br /&gt;
CST Central Standard Time(USA) UT-6:00
CST Central Standard Time(Australia) UT 9:30
&lt;strong&gt;CST China Standard Time UT 8:00&lt;/strong&gt;
CST Cuba Standard Time UT-4:0&lt;br /&gt;
我们常遇到的应该就是 China Standard Time.&lt;/p&gt;

&lt;h4 id=&#34;toc_17&#34;&gt;GMT 和 UTC 的关系&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;UTC (Universal Time Coordinated), 以子午初线(经度0)上的评价太阳时为依据, 也就是英国伦敦的平均太阳时&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GMT (Greenwitch Mean Time) 格林威治平均时间, 由于地球绕太阳的运行的轨道是椭圆, 导致 UTC 表示的时间, 不是很准确, 因此提出了 GMT 时间, 每年或者2年对 UTC 增加一个闰秒, 来完成修正.  一般上我们可以认为 GMT 和 UTC 是一样的.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_18&#34;&gt;Golang 设置时区&lt;/h3&gt;

&lt;h4 id=&#34;toc_19&#34;&gt;背景&lt;/h4&gt;

&lt;p&gt;最近在给运营同学做一个定时和实时配送策略文件的时候, 遇到一个问题: 对于运营同学自然不可能要求他们会 crontab, 因此和运营同学约定设置配送格式为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File  Time
a.txt  08:30:00  #早上8点定时配送
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台程序的设计思路其实很简单, 就是通过&lt;strong&gt;对比当前时间和配置时间&lt;/strong&gt; 如果当前时间大于配置时间的话, 就采用最近的时间进行配置.&lt;/p&gt;

&lt;p&gt;发现问题是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    settingTime := &amp;quot;2015-01-11 15:04:05&amp;quot;
    t, _ := time.Parse(layout, settingTime)
    fmt.Println(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回时间如下, 也就是说默认返回的是 UTC 时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-01-11 15:04:05 +0000 UTC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用 &lt;code&gt;time.Now()&lt;/code&gt; 得到的是 &lt;code&gt;2015-01-11 22:37:03.437033928 +0800 CST&lt;/code&gt; CST 时间.&lt;br /&gt;
UTC 和 CST 的时间相差8小时, 因此为了方便运营同学配置, 需要将加载的配置时间设置为 CST.&lt;/p&gt;

&lt;h4 id=&#34;toc_20&#34;&gt;解决方案&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func StrToTime(timeStr string) (time.Time, error) {
    loc, _ := time.LoadLocation(&amp;quot;Asia/Chongqing&amp;quot;)
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    fmt.Println(&amp;quot;time star parse is : &amp;quot;, timeStr)
    return time.ParseInLocation(layout, timeStr, loc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方案2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func StrToTime(timeStr string)(time.Time, error) {
    loc := time.FixedZone(&amp;quot;CST&amp;quot;, 3600 * 8) 
    layout := &amp;quot;2006-01-02 15:04:05&amp;quot;
    return time.ParseInLocation(layout, timeStr, loc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_21&#34;&gt;Golang 获取文件 mtime, ctime, atime&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func statTimes(name string)(atime, ctime, time time.Time, err error) {
    fi, err := os.Stat(name)
    if err != nil {
        return 
    }
    mtime = fi.ModTime()
    stat := fi.Sys().(*syscall.Stat_t)
    atime = time.Unix(int64(stat.Atim.Sec), int64(stat.Atim.Nsec))
    ctime = time.Unix(int64(stat.Ctim.Sec), int64(stat.Ctim.Nsec))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_22&#34;&gt;Golang 多文件上传&lt;/h3&gt;

&lt;p&gt;最近计划做一个 Babel项目, 该项目解决的问题是: 办公环境和 IDC 之间由于安全问题, 封锁了网络链路, 只允许部分端口直连, 通过 rz/sz 传输代码也极其不方便, 因此系统提供一个上传和下载功能的简单工具.&lt;br /&gt;
在上传的时候希望能够支持多个文件上传, 调研了一下发现 html 里边对于多个文件上传其实有两种形式的.&lt;/p&gt;

&lt;p&gt;1: 单个上传通道, 支持多个文件上传.&lt;br /&gt;
HTML 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;uploadForm&amp;quot;  enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/upload&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;
#注意 enctype 必须为 multipart/form-data
    &amp;lt;p&amp;gt;Golang Upload&amp;lt;/p&amp;gt; &amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file1&amp;quot; name=&amp;quot;uploadFile&amp;quot; multiple /&amp;gt; #注意这里的 multiple 表明支持多个文件上传.     
    &amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Upload&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func UploadServer(w http.ResponseWriter, r *http.Request) {
    r.ParseMultiPartForm(32 &amp;lt;&amp;lt; 20) // 32M, 在使用 MultiPartForm 之前必须要先调用ParseMultiPartForm  
    if r.MultiPartForm != nil &amp;amp;&amp;amp; r.MultiPartForm.File != nil {
        fhs := r.MultiPartForm.File[&amp;quot;uploadFile&amp;quot;]

        for index, header := range fhs {
            filename := header.Filename
            file, _ := header.Open()
            defer file.Close()

            //save file to disk
            f, err := os.Create(filename)
            defer f.Close()

            io.Copy(f, file)

            fstat, _ := f.Stat()
            fmt.Fprintf(w, &amp;quot;No: %d, Size:%d KB Name:%s&amp;quot;, index, fstat.Size()/1024, filename)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多个上传通道, 本质上其实和方案一样, 差异在 HTML.
HTML 代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;form action=&amp;quot;/v1/dispatch&amp;quot; method=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name = &amp;quot;uploadFiles[]&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; class=&amp;quot;btn&amp;quot; value=&amp;quot;上传文件&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.Ctx.Request.ParseMultipartForm( 10 * (8 &amp;lt;&amp;lt; 20))
fhs := this.Ctx.Request.MultipartForm.File[&amp;quot;uploadFiles[]&amp;quot;]
var forgetMeta bool = true
var realtime bool = false


for index, f := range fhs {
    file, err := f.Open()
    defer file.Close()


    if err != nil {
        beego.Warn(&amp;quot;open file failed.&amp;quot;)
    }else{
    beego.Trace(&amp;quot;ok, I get &amp;quot;,index,&amp;quot;th file:&amp;quot;, f.Filename)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它知识点:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; options := r.MultipartForm.Value[&amp;quot;options[]&amp;quot;] #获取HTML数组内容.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果form里面变量都是唯一的，直接用parseFormValue，和parseFile就可以，因为返回的都是单个变量而不是一个数组了，省的另外操作数组。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;## Golang post https 服务
 ### 背景
 公司有一个服务是利用 https 提供服务的, 在改域名下提供一个 http 接口.  利用 curl POST&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; curl  -d &#39;name=foo&#39; https://foo.bar.com 
 提示错误: Get https://golang.org/: certificate is valid for *.appspot.com, *.*.appspot.com, appspot.com, not golang.org

 curl -d &#39;name=foo&#39; -k  https://foo.bar.com 才可以  

 -k, --insecure
          (SSL)  This option explicitly allows curl to perform &amp;quot;insecure&amp;quot; SSL connections and transfers. All SSL connections are attempted to be made secure
          by using the CA certificate bundle installed by default. This makes all connections considered &amp;quot;insecure&amp;quot; fail unless -k, --insecure is used.

          See this online resource for further details: http://curl.haxx.se/docs/sslcerts.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;golang 代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;crypto/tls&amp;quot;
)

func main() {
    transport := &amp;amp;http.Transport{
        TLSClientConfig : &amp;amp;tls.Config{InsecureSkipVerify: true},
    }

    client := &amp;amp;http.Client{Transport: transport}

    _, err := client.Get(&amp;quot;https://golang.org/&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/12122159/golang-how-to-do-a-https-request-with-bad-certificate&#34;&gt;refer&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_24&#34;&gt;Go get 工具&lt;/h2&gt;

&lt;p&gt;今天在使用第三方服务的时候, 在使用一个项目的时候, 需要获取对应的 package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go  get  ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; 命令了解, 可是有&lt;code&gt;threee dot&lt;/code&gt; 没有看到对应的文档说明, 只能阅读对应的代码. 发现原来是这样的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// downloadPaths prepares the list of paths to pass to download.
// It expands ... patterns that can be expanded.  If there is no match
// for a particular pattern, downloadPaths leaves it in the result list,
// in the hope that we can figure out the repository from the
// initial ...-free prefix.
func downloadPaths(args []string) []string {
args = importPathsNoDotExpansion(args)
var out []string
for _, a := range args {
    if strings.Contains(a, &amp;quot;...&amp;quot;) {
        var expand []string
        // Use matchPackagesInFS to avoid printing
        // warnings.  They will be printed by the
        // eventual call to importPaths instead.
        if build.IsLocalImport(a) {
            expand = matchPackagesInFS(a)
        } else {
            expand = matchPackages(a)
        }
        if len(expand) &amp;gt; 0 {
            out = append(out, expand...)
            continue
        }
    }
    out = append(out, a)
}
return out
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go get 在获取到对应的下载的 path 的时候, 对 &lt;code&gt;...&lt;/code&gt; 进行特殊处理, &lt;code&gt;...&lt;/code&gt; 作用就是&lt;strong&gt;对该目录下的所有文件进行 go get&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_25&#34;&gt;Go log 知识点&lt;/h2&gt;

&lt;p&gt;程序中输出日志其实是一件艺术的事情, 首先日志一定要有, 不然出现问题的时候就悲剧了, 根本就无从下手. 然后日志要详细但是不啰嗦. 太过啰嗦很容易导致有用的信息被淹没&lt;br /&gt;
golang 语言中自己就提供了 log 库.&lt;/p&gt;

&lt;h3 id=&#34;toc_26&#34;&gt;log 如何写入到磁盘中&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;f, err :=  os.OpenFile(logFile, os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666)
log.SetOutput(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_27&#34;&gt;日志如何设置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_28&#34;&gt;Golang 判断文件是否存在&lt;/h2&gt;

&lt;h3 id=&#34;toc_29&#34;&gt;文件存在&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if _, err := os.Stat(filename); err == nil {
    fmt.Println(&amp;quot;file exists&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_30&#34;&gt;文件不存在&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if _, err := os.Stat(filename); os.IsNotExist(err) {
    fmt.Println(&amp;quot;no such filename&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_31&#34;&gt;好奇os.IsNotExist(err) 如何获取到错误类型?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// IsNotExist returns a boolean indicating whether the error is known to
// report that a file or directory does not exist. It is satisfied by
// ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool {
    return isNotExist(err)
}
#其中 isNotExist() 是为了实现跨平台, 在 error_plan9.go 和 error_unix.go 和 error_windows.go 里边分别实现了 isNotExist. 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nmap Draft</title>
      <link>http://yujinqiu.github.io/posts/NmapHack/</link>
      <pubDate>Thu, 04 Dec 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/NmapHack/</guid>
      <description>

&lt;p&gt;#nmap 简单介绍&lt;/p&gt;

&lt;p&gt;本文的切入点:hacker使用Nmap的流程角度来介绍如何掌握Nmap这个强大的工具,帮助安全管理员发现自己网站的漏洞, 并逐步加固自己的安全.&lt;/p&gt;

&lt;p&gt;nmap(network mapper) 主要用途&lt;br /&gt;
- 网络发现&lt;br /&gt;
- 安全扫描
- 端口扫描
- 网络审查&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;nmap 命令选项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap [-s (Scan Type)] [Options] {target specification}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Let&amp;rsquo;s start hack&lt;/h2&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;确定网络的主机&lt;/h3&gt;

&lt;p&gt;hacker使用Nmap来扫描整个网络。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sP 192.168.1.0/24  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-sP 表示ping scanning, nmap 发送ICMP echo request 到每个机器, 返回echo response的机器是存活状态. 但是有些站点会屏蔽echo request , 因此nmap 会发送一个TCP ack packet 到端口80 (by default), 如果获取到RST, 那么也可以确定是
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;强制使用TCP ACK(PA) 或者 TCP SYN(PS) 来进行存活探测&lt;/h4&gt;

&lt;p&gt;有些机器或者firewall 会关闭&lt;strong&gt;ICMP response&lt;/strong&gt;, 我们可以强制使用&lt;strong&gt;TCP ACK&lt;/strong&gt; 或者&lt;strong&gt;TCP SYN&lt;/strong&gt;来进行扫描.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use -PA&amp;lt;port1&amp;gt;[,port2][...].  The default port is 80, since this port is often not filtered out.  Note that this option now accepts multiple, comma-separated port numbers.

nmap -PS 80,81 192.168.1.101
nmap -PA 8888,8889192.158.1.101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap ip1 ip2 ip3
nmap 192.168.1.*
nmap 192.168.1.101,102,103
nmap 191.168.1.101-201
nmap 129.168.1.101-201 --exclude=192.168.1.150  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;端口扫描&lt;/h3&gt;

&lt;p&gt;确定在子网内的机器ip之后就可以针对某些特定的机器进行端口扫描.
1: 使用TCP连接进行扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sT 192.168.1.2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;本机会利用connect() 和远程进行进行创建连接, 如果远程的机器端口是Listened, connect() 会成功  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点: 不需要root权限就能够进行
缺点: 该扫描很容易被远程机器探测到, 远程的机器会记录创建连接和错误日志.&lt;/p&gt;

&lt;p&gt;2: 隐蔽扫描(stealth scanning)
使用TCP SYN扫描来解决上面的问题, 这种方式通常叫&amp;rdquo;half-open scanning&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sS 192.168.1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap 做了什么事情?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;本机发送SYN, 如果端口listen那么就返回 ACK|SYN,本机收到之后返回RST来断开连接.  如果返回RST那么表示该端口没有listen. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点: half-open scanning 相对来说比较难被发现在扫描
缺点:执行该操作需要root 权限, 因为需要构建SYN包.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;防火墙检查&lt;/h3&gt;

&lt;p&gt;检查目标机器是否在防火墙或者packet filter之后?　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sA 192.168.0.101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;检测刚刚启动的host&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap -sP  192.168.1.*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;操作系统识别(OS Fingerprinting)&lt;/h3&gt;

&lt;p&gt;hacker可能对某个os的漏洞很熟悉, 能够轻易进入该操作系统的机器.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -O ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;indent 扫描&lt;/h3&gt;

&lt;p&gt;hacker 会选择一台对某些进程存在漏洞的电脑, 比如一个root运行的webserver, 如果目标机器运行了identd(前提哦,identd是一个协议的实现) 通过 &lt;code&gt;-l&lt;/code&gt;选项能够进行查看哪个用户拥有http守护进程.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -sT -p 80 -l -O www.yourserver.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache运行在root下，是不安全的实践，你可以通过把/etc/indeed.conf中的&lt;strong&gt;auth服务注销&lt;/strong&gt;来阻止ident请求，并重新启动ident。另外也可用使用ipchains或你的最常用的防火墙，在网络边界上执行防火墙规则来终止ident请求，这可以阻止来路不明的人探测你的网站用户拥有哪些进程。&lt;/p&gt;

&lt;p&gt;###快速扫描
 只进行nmap-services 文件中列出的服务进行检测.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -F 192.168.1.101  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;### TCP端口扫描&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap -p -T:8888,80 192.168.1.101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;常用选项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-p 指定端口 -p 21,22,23
-v verbose mode 详细模式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;检测host 服务的版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nmap -sV www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;小结：　　&lt;/h3&gt;

&lt;p&gt;使用什么样的方法来抵制一个黑客使用Nmap，这样的工具是有的，比如 Scanlogd, Courtney, and Shadow;，然而使用这样的工具并不能代替网络安全管理员。因为扫描只是攻击的前期准备，站点使用它只可以进行严密的监视。 使用Nmap监视自己的站点，系统和网络管理员能发现潜在入侵者对你的系统的探测。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MysqlDraft</title>
      <link>http://yujinqiu.github.io/posts/MysqlDraft/</link>
      <pubDate>Thu, 04 Dec 2014 13:53:18 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/MysqlDraft/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Mysql多列去重&lt;/h2&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在项目中通常需要我们对数据进行去重, 第一反应应该是使用&lt;code&gt;distinct&lt;/code&gt; 来进行去重, 假设数据如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;monalisa&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;monalisa&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;test&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;demo&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;select distinct name , age from driver; 但是很多时候我们需要保留 id

mysql&amp;gt; select distinct name , age from driver;
+----------+------+
| name     | age  |
+----------+------+
| monalisa |  100 |
| foo      |  100 |
| monalisa |   26 |
| bar      |  100 |
| test     |  100 |
| demo     |  100 |
+----------+------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用 &lt;code&gt;select distinct id, name, age from driver&lt;/code&gt; 无法实现想要的效果, 因为 distinct 看来是三元组 [id, name, age], 均不一样.&lt;/p&gt;

&lt;p&gt;可以采用 &lt;code&gt;select id, name, age from driver group by name, age&lt;/code&gt; 来实现.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Mysql 复制行&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;在开发中, 经常需要初始数据, INSERT INTO &lt;TABLE&gt; values (&amp;hellip;.), (&amp;hellip;) , 效率比较慢,  我们经常需要充以后的内容中复制几行.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from driver;
+----+----------+------+
| id | name     | age  |
+----+----------+------+
|  1 | monalisa |  100 |
|  2 | foo      |  100 |
|  3 | monalisa |   26 |
|  4 | foo      |  100 |
|  5 | bar      |  100 |
|  6 | test     |  100 |
|  7 | demo     |  100 |
+----+----------+------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我们需要复制 monalisa 行到新行里边, 然后就可以修改新行内容.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert into driver (name, age) select name,  age from driver where name = &#39;monalisa&#39; ; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Mysql 输出取消 table 内容&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;我们在 Mysql 查询内容的时候, 为方便数据处理, 有时候我们不需要输出结果中带有 table 边框.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-s, --silent        Be more silent. Print results with a tab as separator,
                  each row on new line.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Mysql 异常&lt;/h2&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;1290 the mysql server is running with the read-only option&lt;/h3&gt;

&lt;p&gt;1: 确认权限问题&lt;br /&gt;
2: show variables like &amp;lsquo;%read_only%&amp;lsquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Variable_name  Value
read_only       On #这里应该为 OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3: 设置 read_only = off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set GLOBAL read_only = false;  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CliDraft</title>
      <link>http://yujinqiu.github.io/posts/ParallelDraft/</link>
      <pubDate>Tue, 25 Nov 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/ParallelDraft/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Parallel(并行你的工作2)&lt;/h1&gt;

&lt;p&gt;今天看到看到一篇介绍Parallel 的文章&lt;a href=&#34;http://www.rankfocus.com/use-cpu-cores-linux-commands/&#34;&gt;Use multiple CPU Cores with your Linux commands — awk, sed, bzip2, grep, wc, etc.&lt;/a&gt;, 感觉和实际工作的没有太大的帮助, 因为平时其实很少去压缩和解压缩超大的文件. 因此下面主要结合个人的工作经验,总结几条Parallel的工作.
下面看一下Parallel的图片,感觉有点眼花,很有心理学的图片效果, 相信我Parallel 是一个值得你学习的命令, 所谓事半功倍说的就是它.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.gnu.org/software/parallel/logo-gray+black300.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;典型场景1&lt;/h2&gt;

&lt;p&gt;在日常运维工作中,为了管理大量的机器(1k,1w台机器)我们通常搭建一台中心控制机器, 该机器和线上所有的机器有&lt;a href=&#34;http://todo&#34;&gt;信任关系&lt;/a&gt;, 因此常见的工作就是在中心控制机器上顺序登录各台机器执行命令. 举一个简单的例子, 获取机器的启动时间 &lt;code&gt;uptime&lt;/code&gt; . 考虑到机器的规模,假设是1万台, 我们基本上跑一下要消耗3-5min.&lt;/p&gt;

&lt;p&gt;为了解决上面的问题,我曾经学习了一下 &lt;code&gt;xargs&lt;/code&gt; 命令, 已经能够基本上满足我的要求. 假设机器的列表在 machines 文件内, 那么通过以下命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat machines | xargs -i ssh {} &amp;quot; uptime &amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的命令是逐台机器执行, 好处就是可以省略在bash 里边输入各种 for 循环. 上面的效果和下面的命令一致
&amp;gt;
for host in $( &amp;lt; machines ) ; do ssh ${host} &amp;ldquo; uptime &amp;rdquo; ;done&lt;/p&gt;

&lt;p&gt;如果需要并行执行应该怎么搞? 答案很简单翻一下 xargs 的man 手册你会发现有一个&lt;code&gt;-P&lt;/code&gt; 选项, 表示并发度
&lt;code&gt;-P 0&lt;/code&gt; 表示全部并发.  -P 10 表示10台并发 (&lt;strong&gt;在运维工程中通常需要考虑控制并发度,特别是在日志下载的时候,因为进程会出现宽度被打满的case,要特别注意&lt;/strong&gt;)
因此&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat machines | xargs -i -P 0 ssh {} &amp;quot; uptime &amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;就能实现全部并发. 上面的命令你执行之后会发现由于是并行执行, 因此输出基本上是乱序的. 如果某一台机器执行错误,那么基本上很难定位到是哪台.  所以个人认为 xargs 在进行简单的并行,比如批量重启服务,分发大量小文件还是蛮不错的. 我最常用的命令组合是,来实现快速的文件分发&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
cat machine | xargs -i -P 0 rsync -HavP -e ssh  FILE {}:PATH
&lt;/code&gt;
** 对于错误问题定位xargs 还是不能解决, 因此需要Parallel 来解决.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;典型场景2&lt;/h2&gt;

&lt;p&gt;或许上面的case 还不具有说服力, 那就说说Parallel 解决我最头疼的事情.
也是中控+N 台服务的模型, 只是这次比较恶心的是在N 台服务其中部署了 1 个模块假设名称为 nginx, 为了避免资源浪费你在这N台机器上部署了M个nginx实例. 需要做的事情是然后你需要完成这样的一件间的任务: 更新所有nginx的配置文件, 然后重新reload配置文件.&lt;br /&gt;
通常比较高效的做法是:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将nginx.conf 文件发送所有的机器上&lt;/li&gt;
&lt;li&gt;编写一个nginx_reload.sh 脚本, 也发送到所有的机器上.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;写一个脚本 &lt;strong&gt;nginx_reload.sh&lt;/strong&gt; 类似如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. cat HOSTS | xargs -i -P 0 rsync -HavP -e ssh nginx.conf  ${HOME}/tmp/
2.
for nginx in `ls -d nginx-* `
do
    cp -v $HOME/tmp/nginx.conf $HOME/${nginx}/conf/ ; 
    $HOME/${nginx}/sbin/nginx -s reload ; 
    sleep 1;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方式能够以较小的代价来实现复杂的任务, 但是&lt;strong&gt;问题是: 需要多发送一次nginx_reload.sh, 而且有时候为了线上的部署清晰, 通常还需要删除 nginx_reload.sh, 还需要在运行一次&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;do it in Parallel way&lt;/h2&gt;

&lt;p&gt;通过Parallel 能够十分方便完成上面的内容.&lt;/p&gt;

&lt;p&gt;在编写好&lt;strong&gt;nginx_reload.sh&lt;/strong&gt; 之后利用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
parallel --sshlogin server1,server2,... --tag --basefile $HOME/tmep/nginx_reload.sh --cleanup --onall sh {} ::: $HOME/tmep/nginx_reload.sh 
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Parallel 入门&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;在&lt;a href=&#34;http://www.gnu.org/software/parallel/&#34;&gt;Parallel官网下载&lt;/a&gt;, 安装里边的说明进行安装即可.
**在安装之后, 没有想到原来Parallel 居然是perl 写的 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  bin git:(master) file parallel

parallel: a perl script text executable

➜  bin git:(master)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;常用的选项&lt;/h3&gt;

&lt;p&gt;通常很多新同学在学习新命令的时候,会抱怨命令的选项太多, 其实根本就没有必要记住那么多, 记住最常用的就可以了. 剩下的通过笔记或者man 来查看就可以. 以下是我觉得笔记有用的选项:&lt;/p&gt;

&lt;h4 id=&#34;toc_7&#34;&gt;运行的目标机器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;-S [ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]
--sshlogin [ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]
            Distribute jobs to remote computers. The jobs will be run on a list of
            remote computers.  GNU parallel will determine the number of CPU cores on
            the remote computers and run the number of jobs as specified by -j.  If
            the number ncpu is given GNU parallel will use this number for number of
            CPU cores on the host. Normally ncpu will not be needed.

            An sshlogin is of the form:

              [sshcommand [options]][username@]hostname

            The sshlogin must not require a password.

            The sshlogin &#39;:&#39; is special, it means &#39;no ssh&#39; and will therefore run on
            the local computer.

            The sshlogin &#39;..&#39; is special, it read sshlogins from
            ~/.parallel/sshloginfile

            The sshlogin &#39;-&#39; is special, too, it read sshlogins from stdin (standard
            input).

            To specify more sshlogins separate the sshlogins by comma or repeat the
            options multiple times.

            For examples: see --sshloginfile.

            The remote host must have GNU parallel installed.

            --sshlogin is known to cause problems with -m and -X.

            --sshlogin is often used with --transfer, --return, --cleanup, and --trc.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_8&#34;&gt;清理文件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;       --cleanup
            Remove transferred files. --cleanup will remove the transferred files on
            the remote computer after processing is done.

              find log -name &#39;*gz&#39; | parallel \
                --sshlogin server.example.com --transfer --return {.}.bz2 \
                --cleanup &amp;quot;zcat {} | bzip -9 &amp;gt;{.}.bz2&amp;quot;

            With --transfer the file transferred to the remote computer will be
            removed on the remote computer.  Directories created will not be removed -
            even if they are empty.

            With --return the file transferred from the remote computer will be
            removed on the remote computer.  Directories created will not be removed -
            even if they are empty.

            --cleanup is ignored when not used with --transfer or --return.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_9&#34;&gt;命令输出打tag&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;         --tag    
            Tag lines with arguments. Each output line will be prepended with the
            arguments and TAB (\t). When combined with --onall or --nonall the lines
            will be prepended with the sshlogin instead.

            --tag is ignored when using -u.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_10&#34;&gt;设置并发度&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    --jobs N
    -j N
    --max-procs N
    -P N     Number of jobslots. Run up to N jobs in parallel.  0 means as many as
            possible. Default is 100% which will run one job per CPU core.

            If --semaphore is set default is 1 thus making a mutex.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;分布式计算&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    --transfer (alpha testing)
Transfer files to remote computers. --transfer is used with --sshlogin when the arguments are files and should be transferred to the remote computers. The files will be transferred using rsync and will be put relative to the default login dir.
 E.g.
    echo foo/bar.txt | parallel \ 
        --sshlogin server.example.com --transfer wc
This will transfer the file foo/bar.txt to the computer server.example.com to the file $HOME/foo/bar.txt before running wc foo/bar.txt on server.example.com.
echo /tmp/foo/bar.txt | parallel  --sshlogin server.example.com --transfer wc
This will transfer the file foo/bar.txt to the computer server.example.com to the file /tmp/foo/bar.txt before running wc /tmp/foo/bar.txt on server.example.com.

--transfer is often used with --return and --cleanup.
--transfer is ignored when used with --sshlogin : or when not used with --sshlogin.
--trc filename
Transfer, Return, Cleanup. Short hand for:
--transfer--return filename —cleanup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过组合上面的&amp;ndash;cleanup 和 &amp;ndash;return 选项我们可以很容易实现自动压缩下载&lt;a href=&#34;http://www.rankfocus.com/automagically-compress-file-remotely-downloading-scprsync/&#34;&gt;来源&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function scp_gzip {
    parallel -S $1 --cleanup --return {/}.gz &amp;quot;gzip --best {} -c &amp;gt; {/}.gz&amp;quot; ::: $2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{/} 表示文件的dirname , 假设文件名为 foo.sh  那么 dirname 就是 foo
&amp;ndash;return {/} 表示从server端 rsync 到本地.
&amp;ndash;cleanup 表示rsync 完成之后,会删除 server端的 .gz 文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;::: 表示:::后面内容是前面的{}的参数. 
parallel --tag  traceroute {} ::: iteye.com v2ex.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;tag 能够针对每个输出进行标记, 能够帮助我们了解输出的来源.&lt;/p&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;常见用法&lt;/h3&gt;

&lt;h4 id=&#34;toc_13&#34;&gt;批量并行下载文件&lt;/h4&gt;

&lt;p&gt;假设有一批文件(file1..100)需要下载, 此时我们当然希望越快越好. 可以采用Parallel 轻松解决.
将需要下载的文件写入 jobs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget file1
wget file2
......
wget file100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;parallel -j 0 &amp;lt; jobs&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;toc_14&#34;&gt;替代两层循环&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;(
for gender in M F ; 
do    
    for size in S M L XL XXL ; 
    do      
        echo $gender $size    
    done  
done
) | sort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过以下命令轻松搞定, 懒人总是希望write less , do more.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;parallel echo {} {} ::: M F ::: S M L XL XXL | sort&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;toc_15&#34;&gt;解决ls 等命令参数过多问题.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;When moving a lot of files like this: mv *.log destdir you will sometimes get the error:

bash: /bin/mv: Argument list too long

because there are too many files. You can instead do:

ls | grep -E &#39;\.log$&#39; | parallel mv {} destdir

This will run mv for each file. It can be done faster if mv gets as many arguments that will fit on the line:

ls | grep -E &#39;\.log$&#39; | parallel -m mv {} destdir
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_16&#34;&gt;远程执行命令&lt;/h4&gt;

&lt;p&gt;如最开始的case 讲的那样.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    parallel -S server1,server2,...,server N --tag --cleanup --basefile $HOME/tmp/nginx_reload.sh &#39;sh {}&#39; ::: $HOME/tmp/nginx_reload.sh
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AppleDraft</title>
      <link>http://yujinqiu.github.io/posts/Apple/</link>
      <pubDate>Tue, 25 Nov 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/Apple/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Apple&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;iphone 屏幕小白点怎么开启?&lt;/h2&gt;

&lt;p&gt;看到别人的屏幕有一个小白点, 点击之后出现siri, device, favorites 和 home 怎么打开?&lt;br /&gt;
那个东西叫Assistive Touch , 在 /setting/general/Accessibility/AssistiveTouch 里边可以打开.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;iphone越狱&lt;/h2&gt;

&lt;p&gt;其实不想一开始就写这篇文章,实在受不了美国v版的中文输入法, 就动起了越狱的心思.网上看了有什么pp助手,91助手之类的工具, 本着对国内流氓公司的不信任的关系,另外恰巧在安装&lt;a href=&#34;http://justgetflux.com/&#34;&gt;f.lux&lt;/a&gt; 遇到&lt;a href=&#34;http://evasi0n.com/&#34;&gt;破解的说明&lt;/a&gt;, 具体操作说明很清楚不到10min就越狱完成. 需要注意点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;越狱前强烈建议利用itunes来进行完整备份&lt;/li&gt;
&lt;li&gt;关闭passcode功能&lt;/li&gt;
&lt;li&gt;退出所有的应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mac os X Draft</title>
      <link>http://yujinqiu.github.io/posts/Mac/</link>
      <pubDate>Tue, 25 Nov 2014 21:36:12 CST</pubDate>
      
      <guid>http://yujinqiu.github.io/posts/Mac/</guid>
      <description>

&lt;p&gt;#Mac os X
##Yosemite 升级之后应该进行什么操作?&lt;br /&gt;
1. 从 mavericks 升级到 mac os x 之后, 会遇到一些比较诡异的问题(比如找不到 clang), 下面的命令会帮助你提前避免一些问题.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo xcode-select --install  
sudo xcode-select --switch /Applications/Xcode.app   
sudo xcodebuild -license  
sudo gem update --system  
sudo gem install xcodeproj   
sudo brew update   
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;同时 Yosemite 会收集用户的隐私数据, 建议通过&lt;a href=&#34;https://fix-macosx.com/&#34;&gt;fix-macosx&lt;/a&gt;进行修复&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Mac os X 窗体最小化之后恢复&lt;/h3&gt;

&lt;p&gt;Mac os X 在最小化窗体之后, &lt;code&gt;command + tab&lt;/code&gt; 是不能够直接恢复, 具体操作如下&lt;br /&gt;
command + tab 定位到对应的 Application 然后 &lt;code&gt;alt&lt;/code&gt; 然后同时放开 &lt;code&gt;alt command&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;清除 DNS cache&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo dscacheutil -flushcache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;mac os x 权限位问题&lt;/h3&gt;

&lt;p&gt;在 mac os terminal 中我们经常可以看到 带有 &lt;code&gt;+&lt;/code&gt;  和  &lt;code&gt;@&lt;/code&gt;  的权限问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rw-r--r--@  1 knight  staff      775 Feb 26  2014 Apple.md
-rw-r--r--   1 knight  staff     3608 Oct 25 14:23 CliDraft.md
-rw-r--r--@  1 knight  staff     1208 Nov 16  2013 EspeakDraft.md
-rw-r--r--@  1 knight  staff     3470 Dec 31  2013 FPDraft.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;@ 字符&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@&lt;/code&gt; 表示这个文件拥有扩展的属性( additional attribute) , 可以通过&lt;code&gt;xattr&lt;/code&gt; 来查看详细信息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xattr -l  &amp;lt;filename&amp;gt; 

➜  engineerdraft git:(master) ✗ xattr -l Apple.md
com.apple.TextEncoding: utf-8;134217984
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展的属性用途是: 定义一些打开文件的程序比如 Mou 打开 markdown 文件.&lt;/p&gt;

&lt;h4 id=&#34;toc_4&#34;&gt;+ 字符&lt;/h4&gt;

&lt;p&gt;+ 表示这个文件用户 ACL(Access Control List) 相对于文件的权限能够耕细粒度的控制.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -le 可以查看文件的 acl 权限
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##如何快速访问Menu或者mac访问Menu的快捷键
在window的用户会有这样的习惯, 通过alt来快速访问菜单栏. 在mac 下怎么通过键盘来快速访问?
终于在&lt;a href=&#34;http://lifehacker.com/321595/access-the-dock-and-menu-bar-from-your-keyboard&#34;&gt;access-the-dock-and-menu-bar-from-your-keyboard&lt;/a&gt; 找到方法.    
其实很简单就是通过 &lt;code&gt;ctrl+F2&lt;/code&gt;(menubar) &lt;code&gt;ctrl+F3&lt;/code&gt;(dock), 然后直接输入对应的菜单名称. 比如:&lt;code&gt;View&lt;/code&gt;, 输入回车即可选择, 然后继续输入对应的名称,或者通过方向键即可选择.
打开Menu的Help的快捷键是&lt;code&gt;command + shift + /&lt;/code&gt;, 可以这样记住: shift+/ = ?  快捷键就是command + ? == help&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;mac 计算md5 值&lt;/h2&gt;

&lt;p&gt;在linux 下有md5sum 这个命令, 在mac 下发现居然没有. 仔细查找之后发现原来叫md5. 运行之后发现和md5sum输出的结果不一样, 其实可以利用&lt;code&gt;md5 -r&lt;/code&gt;就可以得到一样的结果.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;mac 版本管理&lt;/h2&gt;

&lt;p&gt;mac 的 keynote, pages, numbers 和原始文本编辑器是具有版本管理的. 入口在&lt;code&gt;File-&amp;gt; revert to -&amp;gt; brow all version&lt;/code&gt;, 可以进入查看和 time machine 一样的界面.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;快速打开stikcy note 快捷键&lt;/h2&gt;

&lt;p&gt;shift+ command + y ,  退出:  command + q&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;屏幕放大&lt;/h2&gt;

&lt;p&gt;ctrl + 鼠标放大,缩小&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;快速预览文件( quick look)&lt;/h2&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;经常我们在命令行里边,看到某个文件之后, 希望能够 quick look, 一般的做法是, open File 打开, 然后关闭, 其实我们只是希望能够简单看一下, 可以利用以下命令来实现 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qlmanage -p  File
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>